<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>js进阶知识梳理 | Vito&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/img/cat.jpg">
    <meta name="description" content="vito的个人网站">
    
    <link rel="preload" href="/assets/css/0.styles.35bcedcf.css" as="style"><link rel="preload" href="/assets/js/app.d6863c70.js" as="script"><link rel="preload" href="/assets/js/2.b49fbb72.js" as="script"><link rel="preload" href="/assets/js/5.4d64fc18.js" as="script"><link rel="prefetch" href="/assets/js/10.01479792.js"><link rel="prefetch" href="/assets/js/11.dbc54a9b.js"><link rel="prefetch" href="/assets/js/12.21ed737d.js"><link rel="prefetch" href="/assets/js/13.667d59e4.js"><link rel="prefetch" href="/assets/js/14.995c41d1.js"><link rel="prefetch" href="/assets/js/15.b8f8ed66.js"><link rel="prefetch" href="/assets/js/16.19490548.js"><link rel="prefetch" href="/assets/js/17.4df9ed35.js"><link rel="prefetch" href="/assets/js/18.2e285514.js"><link rel="prefetch" href="/assets/js/19.f7516b76.js"><link rel="prefetch" href="/assets/js/20.ddd4d919.js"><link rel="prefetch" href="/assets/js/21.649fcf15.js"><link rel="prefetch" href="/assets/js/22.bcdb10cc.js"><link rel="prefetch" href="/assets/js/23.46533836.js"><link rel="prefetch" href="/assets/js/24.5f7b8020.js"><link rel="prefetch" href="/assets/js/25.484a0fd7.js"><link rel="prefetch" href="/assets/js/26.b0d5db33.js"><link rel="prefetch" href="/assets/js/27.9f07023c.js"><link rel="prefetch" href="/assets/js/28.0ade4cb5.js"><link rel="prefetch" href="/assets/js/29.a032bd3c.js"><link rel="prefetch" href="/assets/js/3.afbfed80.js"><link rel="prefetch" href="/assets/js/30.b4858c98.js"><link rel="prefetch" href="/assets/js/31.b8a21cc7.js"><link rel="prefetch" href="/assets/js/32.08f5ea48.js"><link rel="prefetch" href="/assets/js/33.f399c0e0.js"><link rel="prefetch" href="/assets/js/34.093e7c78.js"><link rel="prefetch" href="/assets/js/35.88328e27.js"><link rel="prefetch" href="/assets/js/36.1891ca71.js"><link rel="prefetch" href="/assets/js/37.61af714f.js"><link rel="prefetch" href="/assets/js/38.6ab9e1e4.js"><link rel="prefetch" href="/assets/js/39.2e594a6f.js"><link rel="prefetch" href="/assets/js/4.3b468062.js"><link rel="prefetch" href="/assets/js/40.829ab4fb.js"><link rel="prefetch" href="/assets/js/41.e4506f53.js"><link rel="prefetch" href="/assets/js/42.8891657a.js"><link rel="prefetch" href="/assets/js/43.b10742cf.js"><link rel="prefetch" href="/assets/js/44.ad7bb89d.js"><link rel="prefetch" href="/assets/js/45.0433f91a.js"><link rel="prefetch" href="/assets/js/46.9bc1f75a.js"><link rel="prefetch" href="/assets/js/47.5ff1d32c.js"><link rel="prefetch" href="/assets/js/48.96c01609.js"><link rel="prefetch" href="/assets/js/49.86e28e27.js"><link rel="prefetch" href="/assets/js/50.b58d9b31.js"><link rel="prefetch" href="/assets/js/51.af88a58d.js"><link rel="prefetch" href="/assets/js/6.9a66157a.js"><link rel="prefetch" href="/assets/js/7.aeb62f94.js"><link rel="prefetch" href="/assets/js/8.75119314.js"><link rel="prefetch" href="/assets/js/9.6f7c5e52.js">
    <link rel="stylesheet" href="/assets/css/0.styles.35bcedcf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Vito's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/js/jsBase/" class="nav-link">
  js基础
</a></li><li class="dropdown-item"><!----> <a href="/js/es6+/" class="nav-link">
  es6+基础
</a></li><li class="dropdown-item"><!----> <a href="/js/jsPlus/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  js进阶
</a></li><li class="dropdown-item"><!----> <a href="/js/jsHand/" class="nav-link">
  js手写系列
</a></li><li class="dropdown-item"><!----> <a href="/js/typescript/" class="nav-link">
  typescript
</a></li><li class="dropdown-item"><h4>
          js读书笔记
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/js/jsAsync/" class="nav-link">
  js异步编程
</a></li><li class="dropdown-subitem"><a href="/js/jsDeep/" class="nav-link">
  你不知道的js系列
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Vue" class="dropdown-title"><span class="title">Vue</span> <span class="arrow down"></span></button> <button type="button" aria-label="Vue" class="mobile-dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue/vue2base/" class="nav-link">
  vue2基础
</a></li><li class="dropdown-item"><!----> <a href="/vue/vue2plus/" class="nav-link">
  vue2进阶
</a></li><li class="dropdown-item"><!----> <a href="/vue/vue3base/" class="nav-link">
  vue3基础
</a></li><li class="dropdown-item"><!----> <a href="/vue/vuex/" class="nav-link">
  vuex
</a></li></ul></div></div><div class="nav-item"><a href="/html/" class="nav-link">
  html
</a></div><div class="nav-item"><a href="/css/" class="nav-link">
  css
</a></div><div class="nav-item"><a href="/browser/" class="nav-link">
  浏览器
</a></div><div class="nav-item"><a href="/network/" class="nav-link">
  网络通信
</a></div><div class="nav-item"><a href="/linuxNote/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/devToolsNote/" class="nav-link">
  开发工具
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="https://github.com/vitotu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github主页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/js/jsBase/" class="nav-link">
  js基础
</a></li><li class="dropdown-item"><!----> <a href="/js/es6+/" class="nav-link">
  es6+基础
</a></li><li class="dropdown-item"><!----> <a href="/js/jsPlus/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  js进阶
</a></li><li class="dropdown-item"><!----> <a href="/js/jsHand/" class="nav-link">
  js手写系列
</a></li><li class="dropdown-item"><!----> <a href="/js/typescript/" class="nav-link">
  typescript
</a></li><li class="dropdown-item"><h4>
          js读书笔记
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/js/jsAsync/" class="nav-link">
  js异步编程
</a></li><li class="dropdown-subitem"><a href="/js/jsDeep/" class="nav-link">
  你不知道的js系列
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Vue" class="dropdown-title"><span class="title">Vue</span> <span class="arrow down"></span></button> <button type="button" aria-label="Vue" class="mobile-dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue/vue2base/" class="nav-link">
  vue2基础
</a></li><li class="dropdown-item"><!----> <a href="/vue/vue2plus/" class="nav-link">
  vue2进阶
</a></li><li class="dropdown-item"><!----> <a href="/vue/vue3base/" class="nav-link">
  vue3基础
</a></li><li class="dropdown-item"><!----> <a href="/vue/vuex/" class="nav-link">
  vuex
</a></li></ul></div></div><div class="nav-item"><a href="/html/" class="nav-link">
  html
</a></div><div class="nav-item"><a href="/css/" class="nav-link">
  css
</a></div><div class="nav-item"><a href="/browser/" class="nav-link">
  浏览器
</a></div><div class="nav-item"><a href="/network/" class="nav-link">
  网络通信
</a></div><div class="nav-item"><a href="/linuxNote/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/devToolsNote/" class="nav-link">
  开发工具
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="https://github.com/vitotu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github主页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>js进阶知识梳理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js/jsPlus/#数据类型" class="sidebar-link">数据类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/jsPlus/#数据类型判断与比较" class="sidebar-link">数据类型判断与比较</a></li><li class="sidebar-sub-header"><a href="/js/jsPlus/#变量与数据类型" class="sidebar-link">变量与数据类型</a></li><li class="sidebar-sub-header"><a href="/js/jsPlus/#包装类型" class="sidebar-link">包装类型</a></li><li class="sidebar-sub-header"><a href="/js/jsPlus/#隐式类型转换" class="sidebar-link">隐式类型转换</a></li></ul></li><li><a href="/js/jsPlus/#函数" class="sidebar-link">函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/jsPlus/#this指向问题" class="sidebar-link">this指向问题</a></li><li class="sidebar-sub-header"><a href="/js/jsPlus/#apply、bind、call方法辨析" class="sidebar-link">apply、bind、call方法辨析</a></li><li class="sidebar-sub-header"><a href="/js/jsPlus/#箭头函数" class="sidebar-link">箭头函数</a></li><li class="sidebar-sub-header"><a href="/js/jsPlus/#变量提升和函数提升" class="sidebar-link">变量提升和函数提升</a></li><li class="sidebar-sub-header"><a href="/js/jsPlus/#闭包" class="sidebar-link">闭包</a></li><li class="sidebar-sub-header"><a href="/js/jsPlus/#节流-throttle-与防抖-debounce" class="sidebar-link">节流(throttle)与防抖(debounce)</a></li><li class="sidebar-sub-header"><a href="/js/jsPlus/#flatmap手写实现" class="sidebar-link">flatMap手写实现</a></li></ul></li><li><a href="/js/jsPlus/#js运行机制" class="sidebar-link">js运行机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/jsPlus/#浏览器" class="sidebar-link">浏览器</a></li><li class="sidebar-sub-header"><a href="/js/jsPlus/#事件循环模型" class="sidebar-link">事件循环模型</a></li><li class="sidebar-sub-header"><a href="/js/jsPlus/#事件循环与渲染、帧动画、空闲回调的关系" class="sidebar-link">事件循环与渲染、帧动画、空闲回调的关系</a></li><li class="sidebar-sub-header"><a href="/js/jsPlus/#浏览器的关键渲染路径" class="sidebar-link">浏览器的关键渲染路径</a></li><li class="sidebar-sub-header"><a href="/js/jsPlus/#重排与重绘" class="sidebar-link">重排与重绘</a></li><li class="sidebar-sub-header"><a href="/js/jsPlus/#v8垃圾回收机制" class="sidebar-link">v8垃圾回收机制</a></li></ul></li><li><a href="/js/jsPlus/#面向对象" class="sidebar-link">面向对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/jsPlus/#原型与原型链" class="sidebar-link">原型与原型链</a></li><li class="sidebar-sub-header"><a href="/js/jsPlus/#new操作符" class="sidebar-link">new操作符</a></li></ul></li><li><a href="/js/jsPlus/#前端性能与优化" class="sidebar-link">前端性能与优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/jsPlus/#性能指标" class="sidebar-link">性能指标</a></li><li class="sidebar-sub-header"><a href="/js/jsPlus/#首屏时间优化" class="sidebar-link">首屏时间优化</a></li></ul></li><li><a href="/js/jsPlus/#异步编程" class="sidebar-link">异步编程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js/jsPlus/#promise" class="sidebar-link">Promise</a></li><li class="sidebar-sub-header"><a href="/js/jsPlus/#常见promiseapi" class="sidebar-link">常见promiseApi</a></li><li class="sidebar-sub-header"><a href="/js/jsPlus/#手写promise实现" class="sidebar-link">手写promise实现</a></li><li class="sidebar-sub-header"><a href="/js/jsPlus/#async-await和generator-yield" class="sidebar-link">async/await和generator/yield</a></li></ul></li><li><a href="/js/jsPlus/#补充说明" class="sidebar-link">补充说明</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="js进阶知识梳理"><a href="#js进阶知识梳理" class="header-anchor">#</a> js进阶知识梳理</h1> <p>本笔记中主要整理一些js的进阶知识以及一些相似的知识点整理</p> <h2 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h2> <p>null,undefined,string,Number,boolean;5种基本类型,es6引入了bigint,Symbol两种基本类型<br>
Object引用类型,<br>
总计8种数据类型</p> <h3 id="数据类型判断与比较"><a href="#数据类型判断与比较" class="header-anchor">#</a> 数据类型判断与比较</h3> <p>判断数据类型的方法有</p> <ul><li>typeof 直接进行类型判断</li> <li>instanceof 借用__proto__属性(原型链)关系判断实例是否与函数的prototype相等</li> <li>Object.prototype.toString.call() 借用原型链进行判断</li> <li>constructor 该属性返回实例的构造函数</li> <li>=== 严格比较判断</li></ul> <h4 id="区别"><a href="#区别" class="header-anchor">#</a> 区别</h4> <p>typeof能正确输出变量所属基本类型(null除外)和引用类型中的function，对null和其他引用类型输出object</p> <p>instanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上,也就是顺着原型链去找，直到找到相同的原型对象，对基本类型判断都返回false</p> <p>constructor 则是顺着constructor属性去找</p> <p>区别：</p> <ol><li>typeof会返回一个变量的基本类型(以字符串的形式表示)，instanceof返回的是一个布尔值</li> <li>instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基本数据类型</li> <li>typeof主要用于判断基本类型(null除外),<code>typeof null</code>输出object是js的一个遗留bug</li></ol> <p>通用的判断方式是Object.prototype.toString.call()方法，该方法统一返回字符串格式<code>'[object Xxx]'</code>，<br>
该方法隐含对基本类型转换为包装类型然后调用toString()方法</p> <p>constructor通常用于示例对象访问其构造函数,相比于instanceof可用于判断基本类型<br>
null和undefined没有constructor属性，不能使用此方法进行判断.另外基本类型的constructor属性只读，但引用类型的则可以被修改</p> <p><code>===</code>严格相等判断符，通常用于判断变量是否为null或undefined，变量被声明但未初始化(赋值)时为undefined,<br>
若定义一个变量将来要引用一个对象，通常将其初始化为null，在回收变量时也通常将其赋值为null</p> <p>以下是一些示例</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// '[object Symbol]'  </span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// [object Null]  </span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span> <span class="token comment">// [object Number]  </span>
<span class="token keyword">typeof</span> <span class="token number">NaN</span> <span class="token comment">// number  </span>
<span class="token keyword">null</span> <span class="token keyword">instanceof</span> <span class="token class-name">null</span> <span class="token comment">// 报错  </span>
<span class="token keyword">null</span> <span class="token keyword">instanceof</span> <span class="token class-name">object</span> <span class="token comment">// false  </span>
<span class="token number">1.</span><span class="token class-name">__proto__</span><span class="token punctuation">.</span>constructor <span class="token comment">// 报错 数字后接'.'会被优先解析为小数点  </span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token class-name">__proto__</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Number <span class="token comment">// true  </span>
</code></pre></div><h3 id="变量与数据类型"><a href="#变量与数据类型" class="header-anchor">#</a> 变量与数据类型</h3> <p>严格区别变量类型与数据类型?</p> <ul><li>数据的类型
<ul><li>基本类型</li> <li>对象类型</li></ul></li> <li>变量的类型(变量内存值的类型)
<ul><li>基本类型: 保存就是基本类型的数据</li> <li>引用类型: 保存的是地址值</li></ul></li></ul> <h4 id="的区别"><a href="#的区别" class="header-anchor">#</a> <code>===</code>, <code>==</code>的区别</h4> <ul><li><code>==</code>:比较时会进行必要的类型转换，转换为同一数据类型再进行比较</li></ul> <p>null与undefined相等,NaN不与任何值相等;<br>
字符串与数值比较,会将字符串转为数值再进行比较;<br>
任意值为true时转为1,false转为0再进行比较;<br>
对象与基本数据比较时，会调用对象的valueof或toString方法转换为基础类型进行比较<br>
Number,String,Boolean类型出现在等号两边时,只要类型不同,都转换为Number类型再比较;</p> <ul><li><code>===</code>不会进行类型转换</li></ul> <p>NaN不与任何值相等(包括自身)；<br>
对象类型，两个值都引用同一个对象才相等；<br>
null和undefined与自身相等，但相互不相等</p> <ul><li>另外相等判断时NaN使用isNaN()判断，<br>
ES6中提供了Object.is(obj1,obj2)新的判断方法，该方法与<code>===</code>类似,但额外兼容了NaN,并且认为-0和+0不相等<br>
三种比较方法在进行引用类型之间的比较时，需引用相同的对象时才相等，如：<code>{a:'a'} == {a:'a'}</code>输出false<br> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness" target="_blank" rel="noopener noreferrer">参考文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h3 id="包装类型"><a href="#包装类型" class="header-anchor">#</a> 包装类型</h3> <p>对于基本类型，严格来说是没有任何方法，<br>
如语句<code>'abc'.substring(1,2)</code>表达式应该报错而不是输出b，但实际上存在类似下列过程</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">)</span>  
temp<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>  
temp <span class="token operator">=</span> <span class="token keyword">null</span>  
</code></pre></div><p>这个过程中使用了string类型对应的包装类String，<br>
es6之前只有String(),Number(),Boolean()可以通过new创建包装类，<br>
es6中新增的BigInt，Symbol不可通过new操作符创建包装类<br>
ecma官方建议应当尽量避免显式使用包装类</p> <h3 id="隐式类型转换"><a href="#隐式类型转换" class="header-anchor">#</a> 隐式类型转换</h3> <h4 id="数学运算符中的类型转换"><a href="#数学运算符中的类型转换" class="header-anchor">#</a> 数学运算符中的类型转换</h4> <ul><li>减、乘、除:会将非Number类型转换为Number类型，对于对象类型隐含‘拆箱’操作再转换为Number类型</li> <li>加，当一侧有String时，将另一侧转换为字符串进行拼接；在此基础上，当一侧为Number，另一侧为其他基本类型，则将基本类型转换为Number类型，另一侧为引用类型时，则都转换为String进行拼接</li></ul> <h4 id="逻辑语句中的类型转换"><a href="#逻辑语句中的类型转换" class="header-anchor">#</a> 逻辑语句中的类型转换</h4> <ul><li>单个变量逻辑判断时if,while,!等直接将变量转换为Boolean,类似与Boolean()方法，只有null,undefined,'',NaN,0,false为false，其他为true，如{}, []等</li> <li><code>==</code>,NaN与任何类型比较都为false;</li> <li>Boolean与任何类型比较都转换为Number;</li> <li><code>String==Number</code>,String转换为Number;</li> <li><code>null==undefined</code>为true,与其他非值(自身除外)比较都为false;</li> <li>基本类型和引用类型比较时会遵循先valueof后tostring的模式转换为基本类型,再比较</li></ul> <h2 id="函数"><a href="#函数" class="header-anchor">#</a> 函数</h2> <p>函数有四种方式：作为构造器new调用；作为对象方法调用；正常调用(在当前词法作用域中调用)；间接调用(通过call、apply、bind等方式)</p> <h3 id="this指向问题"><a href="#this指向问题" class="header-anchor">#</a> this指向问题</h3> <p>函数中的this是在运行时确定的，this有4中绑定方式</p> <ol><li>默认绑定<br>
函数独立调用时，默认调用方为全局对象，即window对象；严格模式下为undefined；立即调用函数和函数中被直接调用的函数也是独立调用的一种形式</li> <li>隐式绑定<br>
谁调用该函数，this就执行该对象(当前执行的上下文)</li> <li>显式绑定<br>
使用call、apply、bind方法，这些方法绑定仅第一次有效</li> <li>new绑定<br>
使用new实例化时，this指向实例。绑定优先级为4&gt;3&gt;2&gt;1</li></ol> <p>箭头函数没有自己的this,因此在箭头函数中引用this是引用其父级作用域的this</p> <h3 id="apply、bind、call方法辨析"><a href="#apply、bind、call方法辨析" class="header-anchor">#</a> apply、bind、call方法辨析</h3> <p>此三者都可以改变this指向，其中bind变更this后返回新函数，而apply,call直接运行函数</p> <ul><li><code>fun.apply(obj, args)</code>：obj为this的指向，当obj为null或undefined时，默认指向window。改变fun内部this指向后立即执行一次，指向修改仅当次有效</li> <li><code>fun.call(obj, ...args)</code>：apply接收参数为数组，call接收多个单独的参数值，其他性质与apply相同</li> <li><code>fun.bind(obj, ...args)</code>：传参与call方法类似，但不会执行fun，而是返回一个新函数，并改变新函数的this指向，可传入一部分args参数，新函数调用时也可继续传入剩下的参数
<ul><li>bind是硬绑定，返回的新函数会使用obj去调用原始函数，并传递其他参数，绑定后不能通过显式或硬绑定的方式修改this，只能通过new改变</li> <li>softBind会对指定函数进行封装，调用时首先检查this，如果this为全局对象或undefined则会使用obj调用原函数，否则不会修改this，即softBind绑定可多次修改，最后一次有效。</li></ul></li></ul> <p>实现简易的call、apply、bind、softBind：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// call</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">ctx <span class="token operator">=</span> globalThis</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> args <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从arguments收集参数更具兼容性</span>
  <span class="token keyword">const</span> key <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;key&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  ctx<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 将调用myCall的函数fun绑定到ctx[key]属性上</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> ctx<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用ctx调用fun方法，此次调用fun中this变为ctx</span>
  <span class="token keyword">delete</span> ctx<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 删除fun属性</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span> <span class="token comment">// 返回运行结果</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// apply 实现机制与call类似，不再详细注释</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">ctx <span class="token operator">=</span> globalThis</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> args <span class="token operator">=</span> arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> key <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;key&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  ctx<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> ctx<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">delete</span> ctx<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// bind</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">ctx <span class="token operator">=</span> globalThis</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 将调用myBind的函数暂存为fn</span>
  <span class="token keyword">const</span> args <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">bound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">bound</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当bound的调用方是fn的实例时，则使用该实例调用，对应new操作符，改变绑定this的情况,同时该判断条件使后续的多次绑定无效</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  bound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> fn<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  <span class="token keyword">return</span> bound<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// es6的极简实现bind</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">fakeBind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// softBind</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">mySoftBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">ctx <span class="token operator">=</span> globalThis</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> args <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">bound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span> <span class="token operator">||</span> <span class="token keyword">this</span> <span class="token operator">===</span> globalThis<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 仅调用方为undefined/null或全局对象时，使用绑定的值</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  bound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> fn<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  <span class="token keyword">return</span> bound<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="箭头函数"><a href="#箭头函数" class="header-anchor">#</a> 箭头函数</h3> <ul><li>箭头函数无this</li> <li>不可当做构造函数使用new命令</li> <li>没有arguments对象</li> <li>不可使用yield命令
在其中使用this时指向的时定义是所在作用域</li></ul> <h3 id="变量提升和函数提升"><a href="#变量提升和函数提升" class="header-anchor">#</a> 变量提升和函数提升</h3> <p>使用function定义函数，和使用var定义变量时存在变量提升和函数提升，变量提升先预处理变量后处理函数</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span> <span class="token comment">// function 无论变量和函数的顺序，变量提升先处理，函数提升后处理，因此函数覆盖同名变量  </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> b<span class="token punctuation">)</span> <span class="token comment">// function  </span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  
<span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  
<span class="token keyword">var</span> b<span class="token punctuation">;</span>  
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token comment">// 提升后a被初始化，因此覆盖了a函数  </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token comment">// undefined 变量提升但不会先赋值  </span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token comment">// [Function: d] 函数提升则可立即调用  </span>
<span class="token keyword">function</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  
</code></pre></div><h3 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h3> <p>当函数可以记住并访问其所在的词法作用域，即时函数是在当前词法作用域之外执行，这就形成了闭包</p> <p>闭包应用无处不在，模块化和定时器、ajax、事件监听等用到回调函数的地方
TODO：</p> <h3 id="节流-throttle-与防抖-debounce"><a href="#节流-throttle-与防抖-debounce" class="header-anchor">#</a> 节流(throttle)与防抖(debounce)</h3> <p>主要用于优化高频执行的js</p> <ol><li>防抖(debounce)：触发事件在n秒内只能执行一次，若n秒内重新触发，则重置计时器，多次触发只会执行最后一次；无限延后执行<br>
防抖常用于输入框ajax，判断scroll是否滑到底部，防止表单多次提交(类比游戏中的施法读条前摇)</li> <li>节流(throttle)：连续触发事件，但n秒内只执行一次，节流会稀释函数的执行频率<br>
节流常用于DOM元素拖拽,resize,scroll等事件(类比游戏中的技能cd)</li></ol> <p>两者最大的区别在于，指定时间内，防抖为重复触发无限延后执行，节流为重复触发仅执行一次，不重置计时器，不会无限延后<br>
简而言之：<br>
相同点：n秒内只执行一次<br>
不同点：n秒内重复触发，防抖无限延后执行，节流只执行一次</p> <p>带防抖与节流功能的第三方库：underscore,lodash,Ramda(仅用防抖与节流时不推荐引用)</p> <ul><li>手写防抖节流实现:</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> _self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 为添加对异步请求接口的支持返回promise对象，此处也可直接设置定时器，下同</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res<span class="token punctuation">,</span> rej</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// res接收promise对象会等待promise对象状态翻转，再返回promise对象的结果</span>
      <span class="token function">res</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>_self<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> interval</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> result<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> _self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span><span class="token punctuation">{</span>
      result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res<span class="token punctuation">,</span> rej</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token function">res</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>_self<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> interval<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> result <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="flatmap手写实现"><a href="#flatmap手写实现" class="header-anchor">#</a> flatMap手写实现</h3> <p>flatMap用于将数组展开，并map映射，但官方支持中，实际上是先map后flat，因此会造成如下问题:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=&gt;</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [2, 3, 4, '4,51', 7]</span>
<span class="token comment">// 为解决此问题手写实现flatMap如下</span>
<span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> callback <span class="token punctuation">,</span> ctx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object Array]'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span> data<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">acc <span class="token punctuation">,</span>val</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object Array]'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token comment">// 若为Array，则递归调用flatMap</span>
          result <span class="token operator">=</span>  Demo<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> ctx<span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
          result <span class="token operator">=</span> <span class="token function">callback</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> acc<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">callback</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 测试用例函数</span>
    <span class="token keyword">const</span> testData <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Demo<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>testData<span class="token punctuation">,</span> <span class="token parameter">x</span> <span class="token operator">=&gt;</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Demo<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="js运行机制"><a href="#js运行机制" class="header-anchor">#</a> js运行机制</h2> <p>js执行是会将对象放在堆(heap)中，将基础变量以及对象的引用(指针)放在栈(stack)中;<br>
js还维护了一个执行栈与数据栈意义不同</p> <h3 id="浏览器"><a href="#浏览器" class="header-anchor">#</a> 浏览器</h3> <p>js重要的运行环境之一浏览器，可能时多进程或单进程的；但浏览器都是多线程的。js是单线程的；<br>
不同的浏览器有不同的内核：<code>chrome, Safari:webkit, firefox:Gecko, IE:Trident等</code>，这些内核提供了html，css文档解析，dom/css模块在内存中的管理，布局和渲染以及js解释器等模块，chrome和nodejs中的js解释器为v8</p> <h3 id="事件循环模型"><a href="#事件循环模型" class="header-anchor">#</a> 事件循环模型</h3> <p><img src="/assets/img/eventLoop.7762f10e.png" alt="avatar"><br>
简单理解：<br>
先运行同步代码，绑定DOM事件监听，定时器，发送ajax请求等。其中将异步函数交给事件管理模块，当事件触发时，管理器将回调函数添加到任务队列，主线程不断从任务队列中取出任务执行。</p> <p>更进一步的：<br>
任务队列又分为宏任务(macro task)和微任务(micro task)，其中由Promise和MutationObserver传入的回调函数属于微任务，而setTimeout和setInterval属于宏任务；js的初始化代码执行完后会优先处理微任务队列中的所有事件，然后是宏任务。<br>
示例代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>  
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span>  
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token comment">// 输出为:1 3 4 6 5 2  </span>
<span class="token comment">// new Promise时传入的匿名函数是同步代码,then中的为回调微任务  </span>
<span class="token comment">/**
 * 另外后面的手写promise实现章节中可以看出，
 * 使用Promise.resolve方法若参数为Promise对象
 * 则会在内部调用一次then方法，额外产生一次微任务,
 * 同理在then中传入的函数若返回为Promise对象，也会额外调用一次Promise方法产生额外的微任务；
 * 在async/await的手写实现中，对于Promise对象使用await/yield也相当与一次then方法
 */</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">p3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">p3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">&quot;p3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">&quot;p2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">p1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">&quot;p1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Output: p1、p3、p2</span>
<span class="token comment">// 在同步代码运行完成后，p3,p2都额外提交了一个空的微任务，因此p1优先被打印</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 额外产生了1个空的微任务，但具体底层实现时实际产生了两个微任务，因此延后到了3之后打印</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出为 0,1,2,3,4</span>
</code></pre></div><h3 id="事件循环与渲染、帧动画、空闲回调的关系"><a href="#事件循环与渲染、帧动画、空闲回调的关系" class="header-anchor">#</a> 事件循环与渲染、帧动画、空闲回调的关系</h3> <p>空闲回调requestIdleCallback维护一个队列，在浏览器空闲时执行<br>
帧动画requestAnimationFrame在每次重新渲染前调用<br>
浏览器的渲染和代码执行使用了不同的引擎，每轮事件循环不一定伴随着渲染，而微任务队列和宏任务队列也都不止一个<br>
微任务执行完成后会判断rendering opportunity，若需要渲染则依次执行以下方法resize、scroll、requestAnimationFrame回调、IntersectionObserver回调、执行渲染，判断宏任务和微任务队列是否为空，为空则执行requestIdleCallback回调。
详细参考文档：
<a href="https://juejin.cn/post/6844904165462769678" target="_blank" rel="noopener noreferrer">参考文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="浏览器的关键渲染路径"><a href="#浏览器的关键渲染路径" class="header-anchor">#</a> 浏览器的关键渲染路径</h3> <ol><li>生成DOM</li></ol> <p><img src="/assets/img/html-parse.bcc3a20e.png" alt="avatar"></p> <ol start="2"><li>解析css文件，生成cssom</li></ol> <p><img src="/assets/img/cssom.56b74200.png" alt="avatar"></p> <ol start="3"><li>DOM与cssom一起生成Render Tree</li></ol> <p><img src="/assets/img/render-tree.aff3b363.png" alt="avatar"></p> <ol start="4"><li>Layout 计算每一个元素在设备视口内的确切位置和大小</li></ol> <p><img src="/assets/img/layout.13d838f2.png" alt="avatar"></p> <ol start="5"><li>Paint 将渲染树中的每个节点转换成屏幕上的实际像素，这一步通常称为绘制或栅格化</li></ol> <p><img src="/assets/img/paint.e01bff4f.png" alt="avatar"></p> <p><a href="https://blog.windstone.cc/browser-env/browser/how-browsers-work.html#_1-%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5" target="_blank" rel="noopener noreferrer">参考文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="重排与重绘"><a href="#重排与重绘" class="header-anchor">#</a> 重排与重绘</h3> <p>重排和重绘是关键渲染路径中的两步:</p> <ul><li>重排(Reflow)：元素的位置发生变动时发生重排，也叫回流。此时在关键渲染路径中的 Layout 阶段，计算每一个元素在设备视口内的确切位置和大小。当一个元素位置发生变化时，其父元素及其后边的元素位置都可能发生变化，代价极高</li> <li>重绘(Repaint): 元素的样式发生变动，但是位置没有改变。此时在关键渲染路径中的 Paint 阶段，将渲染树中的每个节点转换成屏幕上的实际像素，这一步通常称为绘制或栅格化</li></ul> <p>另外，重排必定会造成重绘。以下是避免过多重排重绘的方法</p> <ol><li>使用 DocumentFragment 进行 DOM 操作，不过现在原生操作很少也基本上用不到</li> <li>CSS 样式尽量批量修改</li> <li>避免使用 table 布局</li> <li>为元素提前设置好高宽，不因多次渲染改变位置</li></ol> <p><a href="https://juejin.cn/post/6844903476506394638" target="_blank" rel="noopener noreferrer">更深的渲染原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="v8垃圾回收机制"><a href="#v8垃圾回收机制" class="header-anchor">#</a> v8垃圾回收机制</h3> <p>垃圾回收主要分为引用计数法和标记法(是否可达)<br>
引用计数无法解决循环引用问题；标记法通过根对象层层遍历，标记可访问到对象</p> <p>v8中js的基本数据类型被保存在栈内存中，而引用数据类型在栈中保存着指针，指向堆内存中的对象，栈内存的数据是由操作系统来负责分配和回收，堆内存中由v8进行管理</p> <p>分代回收：v8将堆内存分为两个区域</p> <ul><li>存活周期短(经过一次垃圾回收就被销毁的)的为新生代，内存容量通常较小，使用副垃圾回收器和Scavenge算法进行垃圾回收。</li></ul> <div class="custom-block tip"><p class="custom-block-title">更进一步的</p> <p>新生代还进一步细分为nursery子代和intermediate子代两个区域，对象第一次分配内存时会分到nursery子代，若经过一次垃圾回收该对象还存在则移入intermediate子代，若再经过一次垃圾回收该对象还在新生代则晋升到老生代中</p> <p>任何声明的对象都会被优先分配到新生代中，Scavenge算法将新生代堆分为from-space和to-space，执行步骤如下：</p> <ol><li>标记活动对象和非活动对象</li> <li>from-space中标记存活的对象复制到to-space中并进行整理排序</li> <li>将from-space中的非活动对象内存释放</li> <li>互换from-space和to-space</li></ol></div> <ul><li>存活周期长(经过多次垃圾回收依然存活的)的为老生代，使用主垃圾回收器 + Mark-Sweep &amp;&amp; Mark-Compact算法。新生代中Scavenge速度快，但内存空间消耗大，效率低，老生代空间大，使用Mark-Sweep进行标记和清理
<ol><li>标记阶段：对老生代对象进行第一次扫描，对活动对象进行标记</li> <li>清理阶段：对老生代对象进行第二次扫描，清除未标记的对象，即非活动对象</li> <li>整理阶段(Mark-Compact中特有的)：尽量保持空闲内存连续</li></ol></li></ul> <p><img src="/assets/img/garbageCollection.ca7d4152.png" alt="garbageCollection.png"></p> <ul><li>垃圾回收的性能优化：
<ul><li>全停顿 垃圾回收也需要js引擎执行，且垃圾回收优先于普通代码的执行，此时会造成普通代码的停顿</li> <li>Orinoco优化：orinoco为V8的垃圾回收器的项目代号
<ul><li>增量标记(标记与js代码执行交替进行)</li> <li>惰性清理(需要写屏障，类似java中的锁来保证安全同步)</li> <li>并发</li> <li>并行</li></ul></li></ul></li></ul> <p><a href="https://www.teqng.com/2021/09/01/13%E5%BC%A0%E5%9B%BE%EF%BC%8120%E5%88%86%E9%92%9F%EF%BC%81%E8%AE%A4%E8%AF%86v8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener noreferrer">参考文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="面向对象"><a href="#面向对象" class="header-anchor">#</a> 面向对象</h2> <h3 id="原型与原型链"><a href="#原型与原型链" class="header-anchor">#</a> 原型与原型链</h3> <ul><li>函数类型(可以理解为工厂)独有prototype显式原型属性, 指向用于创建对应实例的原型对象(可以理解为设计图)；</li> <li>原型对象中有一个属性constructor, 它指向函数对象；</li> <li>实例对象(工厂照设计图生产的产品)和函数(函数本身也是对象)都有__proto__属性和constructor属性，分别指向其构造函数的原型和构造函数</li></ul> <p><img src="/assets/img/prototype.5e9c3ecf.svg" alt="avatar"><br>
如图为Foo函数、实例、Function、Object的原型对应关系：<br>
矩形表示实例对象/原型对象，椭圆表示函数对象<br>
红色箭头即为原型链，Function函数对象的constructor指向自己，prototype和__proto__属性指向相同的原型对象<br>
Object的原型对象的原型对象指向null；引用对象的constructor可以被更改，而基本类型的只读</p> <h3 id="new操作符"><a href="#new操作符" class="header-anchor">#</a> new操作符</h3> <p>new操作符用于创建一个给定构造函数的对象实例，其执行过程简单理解为：</p> <ol><li>创建一个空对象obj</li> <li>将obj的<code>[[prototype]]</code>属性指向构造函数construct的原型,即<code>obj.__proto__ = construct.prototype</code></li> <li>将construct的this绑定到obj上，执行construct为obj添加属性和方法</li> <li>construct若无返回值，则默认返回obj，否则返回指定的返回值</li></ol> <p>实现简单的new操作符:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myNew</span><span class="token punctuation">(</span><span class="token parameter">construct<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 1. 创建一个空对象</span>
    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> construct<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// 2. 将obj的[[prototype]]属性指向构造函数的原型对象</span>
    obj<span class="token punctuation">.</span>constructor <span class="token operator">=</span> construct<span class="token punctuation">;</span> <span class="token comment">// 绑定构造函数属性</span>
    <span class="token function">construct</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3.将construct执行的上下文this绑定到obj上，并执行</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>  <span class="token comment">//4. 返回新创建的对象</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用的例子：</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> person1 <span class="token operator">=</span> <span class="token function">myNew</span><span class="token punctuation">(</span>Person<span class="token punctuation">,</span> <span class="token string">'Tom'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span>  <span class="token comment">// Person {name: &quot;Tom&quot;, age: 20}</span>
</code></pre></div><h2 id="前端性能与优化"><a href="#前端性能与优化" class="header-anchor">#</a> 前端性能与优化</h2> <p>前端性能优化主要分为两方面：</p> <ul><li>网络性能优化
<ul><li>优化资源大小：压缩、裁剪、懒加载、预加载等</li> <li>缓存控制：善用http缓存机制，强缓存、协商缓存等</li> <li>网络请求控制：减少请求，连接复用，data url等</li> <li>优化js代码：tree shaking，代码压缩，懒加载，code split等</li> <li>优化首次渲染路径：媒体查询避免不必要的css，js标签async、defer属性避免html阻塞</li></ul></li> <li>数据处理(渲染)性能优化
<ul><li>减少DOM查询</li> <li>使用requestAnimationFrame代替setTimeout和setInterval来更新视图，减少卡顿</li> <li>防抖与节流减少函数执行频次</li> <li>多线程web worker</li> <li>复杂度更低的class风格css选择器，flex代替float</li></ul></li></ul> <h3 id="性能指标"><a href="#性能指标" class="header-anchor">#</a> 性能指标</h3> <p>文档加载相关指标
<img src="https://www.w3.org/TR/navigation-timing-2/timestamp-diagram.svg" alt="avatar"></p> <ul><li>Time to First Byte（TTFB）:浏览器从请求页面开始到接收第一字节的时间，这个时间段内包括 DNS 查找、TCP 连接和 SSL 连接。</li> <li>DomContentLoaded(DCL): DOMContentLoaded 事件触发的时间, html 文档完全加载解析后(无需等待样式表、图像、iframe等)</li> <li>Load（L）：onLoad 事件触发的时间。页面所有资源都加载完毕后（比如图片，CSS），onLoad 事件才被触发。</li></ul> <p>内容呈现相关</p> <ul><li>First Paint（FP）：从开始加载到浏览器首次绘制像素到屏幕上的时间，不包括默认的背景绘制，但包括非默认的背景绘制。</li> <li>First Contentful Paint（FCP）：浏览器首次绘制来自 DOM 的内容的时间，内容必须是文本、图片（包含背景图）、非白色的 canvas 或 SVG，也包括带有正在加载中的 Web 字体的文本(使用网络字体时设置<code>font-display: swap;</code>可临时使用系统字体，加载完毕后使用网络字体)。</li> <li>First Meaningful Paint（FMP）：页面的主要内容绘制到屏幕上的时间，采用布局数量最大并且 Web 字体已加载 的时刻作为主要内容绘制的近似时间</li> <li>Largest Contentful Paint（LCP）：可视区域中最大的内容元素呈现到屏幕上的时间</li> <li>Speed Index（SI）：页面可视区域中内容的填充速度的指标，可以通过计算页面可见区域内容显示的平均时间来衡量。</li> <li>First Screen Paint（FSP）:页面从开始加载到首屏内容全部绘制完成的时间</li></ul> <p>交互响应相关</p> <ul><li>Time to Interactive（TTI）:网页第一次完全达到可交互状态的时间点(可持续交互)</li> <li>First CPU Idle（FCI）:页面第一次可以响应用户输入的时间</li> <li>First Input Delay（FID）：用户第一次与页面交互（例如单击链接、点击按钮等）到浏览器实际能够响应该交互的时间。</li> <li>Frames Per Second（FPS）：每秒可以重新绘制的帧数</li></ul> <blockquote><p>其中用户体验的核心指标:</p> <blockquote><p>白屏时间为FP或FCP 也可使用window.performance.timing.domLoading - window.performance.timing.navigationStart来计算<br>
首屏时间FSP,该指标还没有同一计算标准,通常采用时间window.performance.timing.domInteractive - window.performance.timing.navigationStart来计算<br>
可交互时间FCI<br>
可流畅交互时间</p></blockquote></blockquote> <p>在chrome中f12开发者工具中的Lighthouse可获取上述部分指标及网页性能报告，而performanc选项则用于收集webapp运行时的性能(与加载性能区别开)
<a href="https://serverless-action.com/fontend/fe-optimization/%E4%BB%8E%E8%BE%93%E5%85%A5%20URL%20%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F.html#%E5%8F%82%E8%80%83" target="_blank" rel="noopener noreferrer">参考文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="首屏时间优化"><a href="#首屏时间优化" class="header-anchor">#</a> 首屏时间优化</h3> <ol><li>对于pv量(page view)比较高的页面，比如 b 站等流量图也比较大的，采用 ssr 采用 ssr 如何优化性能
<ul><li>性能瓶颈在于 react-dom render/hydrate 和 server 端的 renderToString</li> <li>尽量减少 dom 结构， 采用流式渲染，jsonString 一个对象，而不是 literal 对象</li> <li>server 去获取数据</li> <li>不同情况不同分析，减少主线程阻塞时间</li> <li>减少不必要的应用逻辑在服务端运行</li></ul></li> <li>减少依赖和包的体积
<ul><li>利用 webpack 的 contenthash 缓存</li> <li>重复依赖包处理，可以采用 pnpm</li> <li>采用 code splitting，减少首次请求体积</li> <li>减少第三方依赖的体积</li></ul></li> <li>网络 prefetch cdn</li></ol> <h2 id="异步编程"><a href="#异步编程" class="header-anchor">#</a> 异步编程</h2> <ul><li>js中常见的异步方式：
<ol><li>回调函数(如：定时器中的回调函数)；</li> <li>事件监听；</li> <li>发布订阅；</li> <li>Promise；</li> <li>生成器；</li> <li>async/wait</li></ol></li></ul> <h3 id="promise"><a href="#promise" class="header-anchor">#</a> Promise</h3> <ul><li><p>Promise是js中用来替代回调的新的异步解决方案，其本质是一个构造函数，封装异步操作获取异步操作的成功或失败的结果。</p></li> <li><p>promise的状态改变只能是：pending=&gt;resolved或pending=&gt;rejected,且只能变一次。调用resolve则会将状态从当前pending改为resolved，调用reject或抛出错误则将当前状态由pending改为rejected</p></li> <li><p>promise之前的回调方式的异步，在嵌套回调时存在无限嵌套的回调地狱问题，而promise通过链式调用能够避免该问题</p></li> <li><p>promise可以利用then方法返回新的promise机制串联多个任务，想要结束promise链只能在回调中返回一个pending状态的promise</p></li></ul> <h3 id="常见promiseapi"><a href="#常见promiseapi" class="header-anchor">#</a> 常见promiseApi</h3> <ul><li>promise构造函数：<code>new Promise(executor){}</code> <ul><li>executor执行器参数为函数，会在promise内部立即同步调用<code>(resolve, reject)=&gt; {}</code></li> <li>resolve 成功时调用的函数</li> <li>reject 内部失败时调用的函数</li></ul></li> <li><code>Promise.prototype.then(onResolve, onReject)</code>方法,返回一个新的promise对象
<ul><li>onResolve成功时的回调</li> <li>onRejected函数: 失败的回调函数</li></ul></li> <li><code>Promise.prototype.catch(onReject)</code>，语法糖，相当于then(undefined,onReject)</li> <li><code>Promise.resolve(value)</code>返回一个成功的promise对象,成功的数据为value或promise对象</li> <li><code>Promise.reject(reason)</code>返回一个失败的 promise 对象</li> <li><code>Promise.all(promises)</code>返回一个新的 promise, 只有所有的promise都成功才成功,成功数据为promises成功数据组成的数组, 只要有一个失败了就直接失败，失败信息为失败的那个promise信息</li> <li><code>Promise.race(promises)</code>返回promises数组中最先返回的那个promise的结果状态</li></ul> <h3 id="手写promise实现"><a href="#手写promise实现" class="header-anchor">#</a> 手写promise实现</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyPromise</span> <span class="token punctuation">{</span>
  status <span class="token operator">=</span> <span class="token string">&quot;pending&quot;</span><span class="token punctuation">;</span> <span class="token comment">// promise状态</span>
  result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 返回结果</span>
  callback <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 用于异步任务中缓存回调函数</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 构造函数传入executor执行器</span>
    <span class="token keyword">const</span> _self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 保存对象的this便于在回调函数中使用</span>

    <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 成功时的状态翻转函数</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>_self<span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token string">&quot;pending&quot;</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 保证状态只能从pending翻转</span>
      _self<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token string">&quot;fulfilled&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 翻转状态</span>
      _self<span class="token punctuation">.</span>result <span class="token operator">=</span> data<span class="token punctuation">;</span> <span class="token comment">// 保存回调执行结果</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span> <span class="token comment">// 用于支持异步回调</span>
        _self<span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          item<span class="token punctuation">.</span><span class="token function">onResolved</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取出异步任务中缓存的回调函数并执行</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 失败时的状态翻转函数</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>_self<span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token string">&quot;pending&quot;</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
      _self<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token string">&quot;rejected&quot;</span><span class="token punctuation">;</span>
      _self<span class="token punctuation">.</span>result <span class="token operator">=</span> err<span class="token punctuation">;</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        _self<span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          item<span class="token punctuation">.</span><span class="token function">onRejected</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment">// 执行器执行，由此看出在new promise时，executor中的同步代码是同步执行的</span>
      <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">onResolved<span class="token punctuation">,</span> onRejected</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 接受成功和失败时的回调函数</span>
    <span class="token keyword">const</span> _self <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token comment">// 同样保存一下this方便使用</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res<span class="token punctuation">,</span> rej</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span> <span class="token comment">// then 返回一个新的promise</span>
      <span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 判断回调函数的返回值是否为promise，若为promise则根据其结果返回，否则直接返回回调函数的调用结果</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span>_self<span class="token punctuation">.</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span>result <span class="token keyword">instanceof</span> <span class="token class-name">MyPromise</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            result<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">r</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
              <span class="token function">res</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token parameter">e</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
              <span class="token function">rej</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">res</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">rej</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token string">&quot;fulfilled&quot;</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// executor中执行同步任务后翻转了状态则直接运行回调</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 立即加入宏任务队列中，支持回调异步任务</span>
          <span class="token function">callback</span><span class="token punctuation">(</span>onResolved<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token string">&quot;rejected&quot;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
          <span class="token function">callback</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token string">&quot;pending&quot;</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 当executor中的执行的是异步任务，此时状态为pending，需要将回调函数推入缓存，待到状态翻转时再调用</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
          <span class="token function-variable function">onResolved</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">callback</span><span class="token punctuation">(</span>onResolved<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> 
          <span class="token function-variable function">onRejected</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">callback</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">catch</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// catch是then的语法糖，仅接收onRejected</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 绑定在类上的resolve方法，传入promise时，根据其结果返回状态，否则返回成功的且结果为data的新promise对象</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res<span class="token punctuation">,</span> rej</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>data <span class="token keyword">instanceof</span> <span class="token class-name">MyPromise</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        data<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">r</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token function">res</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token function">rej</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token function">res</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 返回新的promise对象，状态为rejected，结果为err</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res<span class="token punctuation">,</span> rej</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">rej</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">static</span> <span class="token function">all</span><span class="token punctuation">(</span><span class="token parameter">promises</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 传入promise数组，当所有promise都成功时返回成功的promise，结果是所有promise成功结果组成的数组，当有一个promise失败时直接返回失败的结果</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res<span class="token punctuation">,</span>rej</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        promises<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">r</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
          count<span class="token operator">++</span><span class="token punctuation">;</span>
          arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">;</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">===</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 翻转数量和promise长度相同时，翻转返回新promise对象的状态</span>
            <span class="token function">res</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token parameter">e</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
          <span class="token function">rej</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">race</span><span class="token punctuation">(</span><span class="token parameter">promises</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 当第一个promise翻转状态时直接返回相同状态的新promise对象</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res<span class="token punctuation">,</span> rej</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        promises<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">r</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
          <span class="token function">res</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token parameter">e</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
          <span class="token function">rej</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">promises<span class="token punctuation">,</span> concurrency</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// map实现多个promise数组并发控制，最多同时运行concurrency个promise任务</span>
    <span class="token keyword">let</span> curIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> resolvedCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>promises<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res<span class="token punctuation">,</span> rej</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">function</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> index <span class="token operator">=</span> curIndex<span class="token punctuation">;</span>
        curIndex<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">&lt;</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
          promises<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">r</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">;</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token parameter">r</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            resolvedCount<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>resolvedCount <span class="token operator">===</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
              <span class="token function">res</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//上一个promise任务执行完成后执行下一个next任务</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> concurrency<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 控制最多同时运行concurrency个next任务</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="async-await和generator-yield"><a href="#async-await和generator-yield" class="header-anchor">#</a> async/await和generator/yield</h3> <p>async/await是generator/yield的语法糖，<br>
generator提供了新的异步方式，遇到yield时暂停程序运行，向外交出执行权，直到外部调用了next方法再回到程序内部继续执行<br>
async/await内置了自动执行器，自动将generator交出的执行权交还给generator</p> <ul><li>手写async/await实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">asyncGeneratorStep</span><span class="token punctuation">(</span><span class="token parameter">gen<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">,</span> _next<span class="token punctuation">,</span> _throw<span class="token punctuation">,</span> key<span class="token punctuation">,</span> arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
      <span class="token keyword">var</span> info <span class="token operator">=</span> gen<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// gen.next(arg) 或 gen.throw(arg)</span>
      <span class="token keyword">var</span> val <span class="token operator">=</span> info<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>info<span class="token punctuation">.</span>done<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 使用promise.resolve的方式能同时支持同步和异步任务val</span>
      Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>_next<span class="token punctuation">,</span> _throw<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">_asyncToGeneratorWrapper</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 返回包装后的函数</span>
      <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> gen <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">function</span> <span class="token function">_next</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 执行器中传入_next未完成时自动循环执行</span>
          Demo<span class="token punctuation">.</span><span class="token function">asyncGeneratorStep</span><span class="token punctuation">(</span>gen<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">,</span> _next<span class="token punctuation">,</span> _throw<span class="token punctuation">,</span> <span class="token string">'next'</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">function</span> <span class="token function">_throw</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          Demo<span class="token punctuation">.</span><span class="token function">asyncGeneratorStep</span><span class="token punctuation">(</span>gen<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">,</span> _next<span class="token punctuation">,</span> _throw<span class="token punctuation">,</span> <span class="token string">'throw'</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">_next</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 启动首次运行</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 测试用例</span>
    <span class="token keyword">function</span> <span class="token function">testFn</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'promise resolve: '</span><span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">testGen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'start run gen'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> res1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">testFn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res1<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> res2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">testFn</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res2<span class="token punctuation">)</span><span class="token punctuation">;</span>      
      <span class="token keyword">let</span> res3 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">testFn</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> res3<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> runner <span class="token operator">=</span> Demo<span class="token punctuation">.</span><span class="token function">_asyncToGeneratorWrapper</span><span class="token punctuation">(</span>testGen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">runner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">end with: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>res<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Demo<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="补充说明"><a href="#补充说明" class="header-anchor">#</a> 补充说明</h2> <p>import模块加载时，传入目录，则优先加载目录下package.json文件中main属性指定的入口，其次是index.js文件；若都没找到则报错</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">5/11/2022, 9:34:43 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d6863c70.js" defer></script><script src="/assets/js/2.b49fbb72.js" defer></script><script src="/assets/js/5.4d64fc18.js" defer></script>
  </body>
</html>
