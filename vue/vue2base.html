<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue2基础使用 | Vito&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/img/cat.jpg">
    <meta name="description" content="vito的个人网站">
    
    <link rel="preload" href="/assets/css/0.styles.3780864a.css" as="style"><link rel="preload" href="/assets/js/app.996fe2d2.js" as="script"><link rel="preload" href="/assets/js/2.84daa104.js" as="script"><link rel="preload" href="/assets/js/15.4de3e399.js" as="script"><link rel="prefetch" href="/assets/js/10.4106c70a.js"><link rel="prefetch" href="/assets/js/11.63fde845.js"><link rel="prefetch" href="/assets/js/12.ee0d6d70.js"><link rel="prefetch" href="/assets/js/13.bd21a21b.js"><link rel="prefetch" href="/assets/js/14.ff2b0bd1.js"><link rel="prefetch" href="/assets/js/16.719ba877.js"><link rel="prefetch" href="/assets/js/17.512fbc18.js"><link rel="prefetch" href="/assets/js/18.920035b0.js"><link rel="prefetch" href="/assets/js/19.ff87200f.js"><link rel="prefetch" href="/assets/js/20.f5344321.js"><link rel="prefetch" href="/assets/js/21.573760fd.js"><link rel="prefetch" href="/assets/js/22.b1aa1065.js"><link rel="prefetch" href="/assets/js/23.c897fa75.js"><link rel="prefetch" href="/assets/js/24.449fe60a.js"><link rel="prefetch" href="/assets/js/25.a8ac45fa.js"><link rel="prefetch" href="/assets/js/26.55ce4a3f.js"><link rel="prefetch" href="/assets/js/27.9f530f24.js"><link rel="prefetch" href="/assets/js/28.c61027f9.js"><link rel="prefetch" href="/assets/js/29.ef2dd2e4.js"><link rel="prefetch" href="/assets/js/3.0d705654.js"><link rel="prefetch" href="/assets/js/30.52382926.js"><link rel="prefetch" href="/assets/js/31.b67bd2c8.js"><link rel="prefetch" href="/assets/js/32.73c6becf.js"><link rel="prefetch" href="/assets/js/33.32bdcd91.js"><link rel="prefetch" href="/assets/js/34.fc092c0b.js"><link rel="prefetch" href="/assets/js/35.251a41b2.js"><link rel="prefetch" href="/assets/js/36.1dc7901c.js"><link rel="prefetch" href="/assets/js/37.1d681294.js"><link rel="prefetch" href="/assets/js/38.0aa813bc.js"><link rel="prefetch" href="/assets/js/39.329302e8.js"><link rel="prefetch" href="/assets/js/4.e5d04c8f.js"><link rel="prefetch" href="/assets/js/40.83af2e80.js"><link rel="prefetch" href="/assets/js/41.e5de706a.js"><link rel="prefetch" href="/assets/js/42.1a01b3be.js"><link rel="prefetch" href="/assets/js/43.71c6362e.js"><link rel="prefetch" href="/assets/js/44.e1bb5ad2.js"><link rel="prefetch" href="/assets/js/45.2d5a1c57.js"><link rel="prefetch" href="/assets/js/46.56669c3e.js"><link rel="prefetch" href="/assets/js/47.9753aa09.js"><link rel="prefetch" href="/assets/js/48.c5f6d332.js"><link rel="prefetch" href="/assets/js/49.9cbca3ad.js"><link rel="prefetch" href="/assets/js/5.6bf5e01f.js"><link rel="prefetch" href="/assets/js/50.8abe6df1.js"><link rel="prefetch" href="/assets/js/51.fd959486.js"><link rel="prefetch" href="/assets/js/52.bab664ef.js"><link rel="prefetch" href="/assets/js/53.c88b7fd9.js"><link rel="prefetch" href="/assets/js/54.eaa93444.js"><link rel="prefetch" href="/assets/js/55.91095fee.js"><link rel="prefetch" href="/assets/js/6.6147797c.js"><link rel="prefetch" href="/assets/js/7.8e346196.js"><link rel="prefetch" href="/assets/js/8.8c4ff8ad.js"><link rel="prefetch" href="/assets/js/9.86225ee7.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3780864a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Vito's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/js/jsBase.html" class="nav-link">
  js基础
</a></li><li class="dropdown-item"><!----> <a href="/js/es6+/" class="nav-link">
  es6+基础
</a></li><li class="dropdown-item"><!----> <a href="/js/jsPlus.html" class="nav-link">
  js进阶
</a></li><li class="dropdown-item"><!----> <a href="/js/jsHand.html" class="nav-link">
  js手写系列
</a></li><li class="dropdown-item"><!----> <a href="/js/typescript/" class="nav-link">
  typescript
</a></li><li class="dropdown-item"><h4>
          js读书笔记
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/js/jsAsync/" class="nav-link">
  js异步编程
</a></li><li class="dropdown-subitem"><a href="/js/jsDeep/" class="nav-link">
  你不知道的js系列
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Vue" class="dropdown-title"><span class="title">Vue</span> <span class="arrow down"></span></button> <button type="button" aria-label="Vue" class="mobile-dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue/vue2base.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  vue2基础
</a></li><li class="dropdown-item"><!----> <a href="/vue/vue2plus/" class="nav-link">
  vue2进阶
</a></li><li class="dropdown-item"><!----> <a href="/vue/vue3base/" class="nav-link">
  vue3基础
</a></li><li class="dropdown-item"><!----> <a href="/vue/vuex/" class="nav-link">
  vuex
</a></li><li class="dropdown-item"><!----> <a href="/vue/vueRouter/" class="nav-link">
  vue router
</a></li></ul></div></div><div class="nav-item"><a href="/html/" class="nav-link">
  html
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="css" class="dropdown-title"><span class="title">css</span> <span class="arrow down"></span></button> <button type="button" aria-label="css" class="mobile-dropdown-title"><span class="title">css</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/css/css3/" class="nav-link">
  图解css3
</a></li><li class="dropdown-item"><!----> <a href="/css/css3plus/" class="nav-link">
  css进阶
</a></li><li class="dropdown-item"><!----> <a href="/css/scss/" class="nav-link">
  scss
</a></li></ul></div></div><div class="nav-item"><a href="/browser/browser.html" class="nav-link">
  浏览器
</a></div><div class="nav-item"><a href="/network/webNetwork.html" class="nav-link">
  网络通信
</a></div><div class="nav-item"><a href="/linuxNote/" class="nav-link">
  Linux
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发构建工具" class="dropdown-title"><span class="title">开发构建工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发构建工具" class="mobile-dropdown-title"><span class="title">开发构建工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/devToolsNote/npm-note.html" class="nav-link">
  npm
</a></li><li class="dropdown-item"><!----> <a href="/webpack/webpackNote.html" class="nav-link">
  webpack基础
</a></li><li class="dropdown-item"><!----> <a href="/webpack/webpack5Note.html" class="nav-link">
  webpack5
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><span class="title">算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="算法" class="mobile-dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/tsClassicTop10SortAlgorithm.html" class="nav-link">
  排序算法
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/tsSword4Offer.html" class="nav-link">
  剑指offer
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/common.html" class="nav-link">
  常见算法
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/10sortedAlgorithm.html" class="nav-link">
  排序算法python
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/python_sword_for_offer.html" class="nav-link">
  剑指offer-python
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/labuladongNote.html" class="nav-link">
  labuladong算法
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/vitotu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github主页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow down"></span></button> <button type="button" aria-label="JavaScript" class="mobile-dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/js/jsBase.html" class="nav-link">
  js基础
</a></li><li class="dropdown-item"><!----> <a href="/js/es6+/" class="nav-link">
  es6+基础
</a></li><li class="dropdown-item"><!----> <a href="/js/jsPlus.html" class="nav-link">
  js进阶
</a></li><li class="dropdown-item"><!----> <a href="/js/jsHand.html" class="nav-link">
  js手写系列
</a></li><li class="dropdown-item"><!----> <a href="/js/typescript/" class="nav-link">
  typescript
</a></li><li class="dropdown-item"><h4>
          js读书笔记
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/js/jsAsync/" class="nav-link">
  js异步编程
</a></li><li class="dropdown-subitem"><a href="/js/jsDeep/" class="nav-link">
  你不知道的js系列
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Vue" class="dropdown-title"><span class="title">Vue</span> <span class="arrow down"></span></button> <button type="button" aria-label="Vue" class="mobile-dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vue/vue2base.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  vue2基础
</a></li><li class="dropdown-item"><!----> <a href="/vue/vue2plus/" class="nav-link">
  vue2进阶
</a></li><li class="dropdown-item"><!----> <a href="/vue/vue3base/" class="nav-link">
  vue3基础
</a></li><li class="dropdown-item"><!----> <a href="/vue/vuex/" class="nav-link">
  vuex
</a></li><li class="dropdown-item"><!----> <a href="/vue/vueRouter/" class="nav-link">
  vue router
</a></li></ul></div></div><div class="nav-item"><a href="/html/" class="nav-link">
  html
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="css" class="dropdown-title"><span class="title">css</span> <span class="arrow down"></span></button> <button type="button" aria-label="css" class="mobile-dropdown-title"><span class="title">css</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/css/css3/" class="nav-link">
  图解css3
</a></li><li class="dropdown-item"><!----> <a href="/css/css3plus/" class="nav-link">
  css进阶
</a></li><li class="dropdown-item"><!----> <a href="/css/scss/" class="nav-link">
  scss
</a></li></ul></div></div><div class="nav-item"><a href="/browser/browser.html" class="nav-link">
  浏览器
</a></div><div class="nav-item"><a href="/network/webNetwork.html" class="nav-link">
  网络通信
</a></div><div class="nav-item"><a href="/linuxNote/" class="nav-link">
  Linux
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发构建工具" class="dropdown-title"><span class="title">开发构建工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发构建工具" class="mobile-dropdown-title"><span class="title">开发构建工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/devToolsNote/npm-note.html" class="nav-link">
  npm
</a></li><li class="dropdown-item"><!----> <a href="/webpack/webpackNote.html" class="nav-link">
  webpack基础
</a></li><li class="dropdown-item"><!----> <a href="/webpack/webpack5Note.html" class="nav-link">
  webpack5
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="算法" class="dropdown-title"><span class="title">算法</span> <span class="arrow down"></span></button> <button type="button" aria-label="算法" class="mobile-dropdown-title"><span class="title">算法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/algorithm/tsClassicTop10SortAlgorithm.html" class="nav-link">
  排序算法
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/tsSword4Offer.html" class="nav-link">
  剑指offer
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/common.html" class="nav-link">
  常见算法
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/10sortedAlgorithm.html" class="nav-link">
  排序算法python
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/python_sword_for_offer.html" class="nav-link">
  剑指offer-python
</a></li><li class="dropdown-item"><!----> <a href="/algorithm/labuladongNote.html" class="nav-link">
  labuladong算法
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/vitotu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github主页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>vue2基础使用</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue/vue2base.html#模板语法" class="sidebar-link">模板语法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#data配置项与响应式" class="sidebar-link">data配置项与响应式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#计算属性computed与监听属性watch" class="sidebar-link">计算属性computed与监听属性watch</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#根实例vm" class="sidebar-link">根实例vm</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#事件处理" class="sidebar-link">事件处理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#绑定样式与class" class="sidebar-link">绑定样式与class</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#列表渲染" class="sidebar-link">列表渲染</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#表单" class="sidebar-link">表单</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#过滤器" class="sidebar-link">过滤器</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#指令" class="sidebar-link">指令</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#生命周期" class="sidebar-link">生命周期</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#组件化编程" class="sidebar-link">组件化编程</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#组件间通信的方式" class="sidebar-link">组件间通信的方式</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#脚手架" class="sidebar-link">脚手架</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#组件属性及配置" class="sidebar-link">组件属性及配置</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#插槽" class="sidebar-link">插槽</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#动态组件和异步组件" class="sidebar-link">动态组件和异步组件</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#过渡" class="sidebar-link">过渡</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#渲染函数与jsx" class="sidebar-link">渲染函数与jsx</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#cookbook" class="sidebar-link">Cookbook</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#添加实例property" class="sidebar-link">添加实例property</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#表单校验" class="sidebar-link">表单校验</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue/vue2base.html#vue-cli" class="sidebar-link">vue-cli</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/vue2base.html#vue-lib模式打包生成umd文件笔记" class="sidebar-link">vue lib模式打包生成umd文件笔记</a></li></ul></li><li><a href="/vue/vue2base.html#关联问题js模块化历史" class="sidebar-link">关联问题js模块化历史</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue2基础使用"><a href="#vue2基础使用" class="header-anchor">#</a> vue2基础使用</h1> <p>参考尚硅谷的vue2教程
视频教程<a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=1" target="_blank" rel="noopener noreferrer">地址<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="模板语法"><a href="#模板语法" class="header-anchor">#</a> 模板语法</h2> <p>vue的<code>.vue</code>文件是SFC(Single File Components 单文件组件)风格的编码，即一个文件中包含了<code>&lt;template&gt;</code>，<code>&lt;script&gt;</code>，<code>&lt;style&gt;</code>，详细如下：</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 在这里书写html及模板语法
此部分将通过@vue/complier-dom的处理，预编译为js的渲染函数render
template本身最终将不会被渲染为DOM结构，并且内部可以多层嵌套template --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token comment">// 在这里书写js</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
<span class="token comment">/* 在这里书写css */</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>与之对应的<code>.jsx</code>风格即是在js中书写xml格式语法用于表示html结构，vue想要使用jsx风格需要自己书写render函数<br>
vue在<code>&lt;template&gt;</code>中书写<code>{ {js表达式}}</code>,<code>v-指令:参数='表达式'</code>等语法样式，这些语法样式由Vue实例来解析。这种方式统称为模板语法</p> <ul><li><code>{ { js表达式 }}</code>:插值语法，其中可以引用组件上的属性，js表达式运行于沙盒中，只能访问<a href="https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9" target="_blank" rel="noopener noreferrer">白名单<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中的全局变量</li> <li>标签/自定义组件上的attribute需要使用<a href="#%E6%8C%87%E4%BB%A4">指令</a>来进行绑定，2.6.0版本后参数支持以<code>[参数js表达式]</code>的形式通过js表达式指定动态参数</li></ul> <h2 id="data配置项与响应式"><a href="#data配置项与响应式" class="header-anchor">#</a> data配置项与响应式</h2> <p>在vm实例中data的配置项可以写成对象形式,但在组件中由于组件的复用特性,data对象必须写成回调函数的形式</p> <p>Vue获取配置项中的data对象后,对data对象进行代理(深度遍历对象给属性添加getter,setter等),然后将改造后的data对象赋给vm实例的<code>_data</code>属性,同时覆盖原有的对象引用,伪代码表示如下:</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// data对象  </span>
<span class="token keyword">let</span> b <span class="token operator">=</span> a  
<span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  
  <span class="token literal-property property">data</span><span class="token operator">:</span>a <span class="token comment">// 省略其他配置项  </span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>  
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_data <span class="token operator">===</span> a<span class="token punctuation">)</span> <span class="token comment">// true  </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_data <span class="token operator">===</span> b<span class="token punctuation">)</span> <span class="token comment">// false  </span>
<span class="token comment">// 原有的对象引用a被覆盖了,因此不等于b对象  </span>
</code></pre></div><p>从data配置向中返回的对象将都具有响应式，即当该数据被修改后所有引用到的地方都会被同步修改</p> <ul><li>响应式基础特性
<ol><li>Vue2在组件实例上设置属性,代理访问data配置项中的数据(vm.key与vm._data.key同源).</li> <li>data配置项中数组对象的响应式是通过数组包装Array类型的原生<code>push()</code>、<code>pop()</code>、<code>shift()</code>、<code>unshift()</code>、<code>splice()</code>、<code>sort()</code>、<code>reverse()</code>等函数来实现的，因此在修改数组类型的数据时，想要响应式的更新都各调用处，需要使用数组方法来修改数组而不是直接使用索引。</li> <li>data配置项中的对象都设置的了数据代理，新加的属性想要获得响应式，需要通过<code>Vue.set(target，propertyName/index，value)</code>方法或方法内<code>vm.$set(target，propertyName/index，value)</code>进行设置</li> <li>特别注意：<code>Vue.set()</code>和<code>vm.$set()</code>不能给vm 或 vm的根数据对象 添加属性！！！</li></ol></li></ul> <p>更深层次的响应式原理参见<a href="/vue/vue2plus/#双向绑定与响应式">响应式原理</a></p> <h2 id="计算属性computed与监听属性watch"><a href="#计算属性computed与监听属性watch" class="header-anchor">#</a> 计算属性computed与监听属性watch</h2> <p>直接在模板语法中无法使用过于复杂的js表达式，computed属性可以用于解决此问题<br>
类似于属性的getter/setter，仅配置一个函数时默认为getter<br>
与methods中的方法相比，computed有基于响应式依赖进行缓存，只有依赖发生变化时才会重新求值，相对而言适用于计算量较大的场景<br>
与watch属性相比，watch属性是更通用的监听数据变化的方法，适用于当数据变化时需要执行异步或开销较大的操作时<br>
更多参见<a href="/vue/vue2plus/#computed原理">computed和watch原理</a></p> <h2 id="根实例vm"><a href="#根实例vm" class="header-anchor">#</a> 根实例vm</h2> <p>vm取名字'mvvm'模型中的最后两个字符vm;model(数据),view(视图html),view-model(视图模型之间的映射)</p> <h2 id="事件处理"><a href="#事件处理" class="header-anchor">#</a> 事件处理</h2> <ul><li><p>Vue中的事件修饰符：<code>v-on:事件名.修饰符=&quot;&quot;</code></p> <ol><li>.prevent：阻止默认事件（常用）；</li> <li>.stop：阻止事件冒泡（常用）；</li> <li>.once：事件只触发一次（常用）；</li> <li>.capture：使用事件的捕获模式；</li> <li>.self：只有event.target是当前操作的元素时才触发事件；</li> <li>.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；与.prevent同时使用时.prevent会被忽略</li> <li>.native: 使用浏览器原生事件</li></ol></li></ul> <p>事件修饰符可以叠加，但会以从左到右顺序生效</p> <ul><li><p>按键<code>v-on:[keyup/keydown等].[按键名]=&quot;&quot;</code></p> <ol><li><p>Vue中常用的按键别名：<br>
回车 =&gt; enter<br>
删除 =&gt; delete (捕获“删除”和“退格”键)<br>
退出 =&gt; esc<br>
空格 =&gt; space<br>
换行 =&gt; tab (特殊，必须配合keydown去使用)<br>
上 =&gt; up<br>
下 =&gt; down<br>
左 =&gt; left<br>
右 =&gt; right</p></li> <li><p>Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）</p></li> <li><p>系统修饰键（用法特殊）：ctrl、alt、shift、meta<br>
1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。<br>
2).配合keydown使用：正常触发事件。</p></li> <li><p>也可以使用keyCode去指定具体的按键（已被废弃）</p></li> <li><p>Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名</p></li> <li><p>.exact用于精确控制系统修饰符组合触发的事件(有且仅有该键被按下时触发)</p></li></ol></li> <li><p>鼠标修饰符<br>
.left<br>
.right<br>
.middle</p></li> <li><p>自定义事件</p></li></ul> <p>自定义事件也可用于父子组件通信<br>
标签中绑定自定义事件的方式:<br> <code>&lt;MyComponent @自定义事件='处理函数'/&gt;</code>或</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyComponent</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>myComponent<span class="token punctuation">'</span></span><span class="token punctuation">/&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">  
  <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>myComponent<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'自定义事件'</span><span class="token punctuation">,</span> 处理函数<span class="token punctuation">)</span>   
  <span class="token comment">// 触发后处理函数的调用方仍然是该组件,  </span>
  <span class="token comment">// 若采用箭头函数,则无法读取当前组件的实例this,因此推荐使用在methods中定义的函数  </span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>myComponent<span class="token punctuation">.</span><span class="token function">$once</span><span class="token punctuation">(</span><span class="token string">'自定义事件a'</span><span class="token punctuation">,</span> 处理函数<span class="token punctuation">)</span> <span class="token comment">// 仅触发一次  </span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  
</code></pre></div><p>被绑上自定义事件的子组件可触发对应的事件并回传数据,如:<code>this.$emit('自定义事件a',params)</code></p> <p>子组件在被销毁前需在beforeDestroy生命周期函数中进行解绑自定义事件<code>beforeDestroy(){this.$off(String单个事件|Array多个事件|不传参默认所有事件)}</code></p> <ul><li>事件总线</li></ul> <p>由于直接使用自定义事件在组件直接进行通讯有局限性,事件总线通过在vue原型上绑定vue根实例vm作为公共组件<code>$bus</code>,在<code>$bus</code>上绑定和触发事件来实现任意组件间的通信,如下代码</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token comment">// 原型上$bus绑定根实例vm  </span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  
 <span class="token literal-property property">el</span><span class="token operator">:</span><span class="token string">'#app'</span><span class="token punctuation">,</span>  
 <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token parameter">h</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">,</span>  
 <span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
  <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$bus <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token comment">//安装全局事件总线  </span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span>  
<span class="token comment">// 任意组件上绑定事件,解绑时请慎用解绑全部事件的写法  </span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$bus<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>  
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我是School组件，收到了数据'</span><span class="token punctuation">,</span>data<span class="token punctuation">)</span>  
<span class="token punctuation">}</span><span class="token punctuation">)</span>  
<span class="token comment">// 另一组件上触发  </span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$bus<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>  
</code></pre></div><p>与事件总线相类似的还有使用第三方库pubsub-js的消息发布订阅方式，用法与事件总线类似</p> <h2 id="绑定样式与class"><a href="#绑定样式与class" class="header-anchor">#</a> 绑定样式与class</h2> <ol><li>class样式<br>
写法<code>:class=&quot;xxx&quot;</code> xxx可以是字符串、对象、数组。<br>
字符串写法适用于：类名不确定，要动态获取。<br>
对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。<br>
数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</li> <li>style样式<br> <code>:style=&quot;{fontSize: xxx}&quot;</code>其中xxx是动态值。<br> <code>:style=&quot;[a,b]&quot;</code>其中a、b是样式对象。</li></ol> <h2 id="列表渲染"><a href="#列表渲染" class="header-anchor">#</a> 列表渲染</h2> <p>可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</p> <blockquote><p>react、vue中的key有什么作用？（key的内部原理）</p></blockquote> <ol><li>虚拟DOM中key的作用：<br>
key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,
随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</li> <li>对比规则：<br>
(1). 旧虚拟DOM中找到了与新虚拟DOM相同的key：<br>
①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！<br>
②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。<br>
(2). 旧虚拟DOM中未找到与新虚拟DOM相同的key<br>
创建新的真实DOM，随后渲染到到页面。</li> <li>用index作为key可能会引发的问题：<br>
a. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:<br>
会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。<br>
b. 如果结构中还包含输入类的DOM：<br>
会产生错误DOM更新 ==&gt; 界面有问题。</li> <li>开发中如何选择key?:<br>
a. 最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。<br>
b. 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，<br>
使用index作为key是没有问题的。</li></ol> <h2 id="表单"><a href="#表单" class="header-anchor">#</a> 表单</h2> <p>使用v-model绑定收集表单数据，对于不同的输入元素将绑定不同的property和事件：</p> <ul><li><code>&lt;input type=&quot;text&quot;/&gt;</code> 和 <code>&lt;textarea/&gt;</code> 元素使用 <code>value</code> property 和 <code>input</code> 事件；</li> <li><code>&lt;input type=&quot;checkbox&quot;/&gt;</code> 和 <code>&lt;input type=&quot;radio&quot;/&gt;</code> 使用 <code>checked</code> property 和 <code>change</code> 事件；多个checkbox可绑定到同一数组上</li> <li><code>&lt;select&gt;</code> 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li></ul> <p>PS：v-model的三个修饰符：<br>
lazy：失去焦点再收集数据<br>
number：输入字符串转为有效的数字<br>
trim：输入首尾空格过滤<br>
关于v-model本质是语法糖，更多详细参见<a href="#%E6%8C%87%E4%BB%A4">指令</a>中v-model和v-bind.sync对比</p> <h2 id="过滤器"><a href="#过滤器" class="header-anchor">#</a> 过滤器</h2> <p>过滤器：(在vue3中被移除)<br>
定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。<br>
语法：<br>
1.注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}<br>
2.使用过滤器：  或  v-bind:属性 = &quot;xxx | 过滤器名&quot;<br>
备注：<br>
1.过滤器也可以接收额外参数、多个过滤器也可以串联<br>
2.并没有改变原本的数据, 是产生新的对应的数据</p> <h2 id="指令"><a href="#指令" class="header-anchor">#</a> 指令</h2> <ul><li>常用的指令：<br>
v-bind : 单向绑定解析表达式, 可简写为 <code>:xxx</code><br>
v-model : 双向数据绑定<br>
v-for   : 遍历数组/对象/字符串(<code>item in items</code>和<code>item of items</code>在Vue中没有区别)<br>
v-on    : 绑定事件监听, 可简写为@<br>
v-if    : 条件渲染（动态控制节点是否存存在）<br>
v-else  : 条件渲染（动态控制节点是否存存在）<br>
v-show  : 条件渲染 (动态控制节点是否展示)</li> <li>v-text指令：<br>
1.作用：向其所在的节点中渲染文本内容。<br>
2.与插值语法的区别：v-text会替换掉节点中的内容，则不会。</li> <li>v-html指令：<br>
1.作用：向指定节点中渲染包含html结构的内容。<br>
2.与插值语法的区别：<br>
(1).v-html会替换掉节点中所有的内容，则不会。<br>
(2).v-html可以识别html结构。<br>
3.严重注意：v-html有安全性问题！！！！<br>
(1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击(如：通过插入html向特定网站发送用户的cookie等数据)。<br>
(2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</li> <li>v-cloak指令（没有值）：<br>
1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。<br>
2.使用css <code>diaplay:none</code>配合v-cloak可以解决网速慢时页面展示出模板<code></code>的问题。</li> <li>v-once指令：<br>
1.v-once所在节点在初次动态渲染后，就视为静态内容了。<br>
2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</li> <li>v-pre指令：<br>
1.跳过其所在节点的编译过程。<br>
2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</li> <li>自定义指令总结：
<ol><li><p>定义语法：<br>
1).局部指令：<br> <code>new Vue({directive:{指令名:配置对象}})</code>或<br> <code>new Vue({directive{指令名:回调函数}})</code> 简写模式回调函数默认是指bind和update<br>
2).全局指令：<br> <code>Vue.directive(指令名,配置对象/回调函数)</code></p></li> <li><p>配置对象中常用的3个回调：<br>
1)<code>bind(element, binding)</code>：指令与元素成功绑定时调用。<br>
2)<code>inserted(element, binding)</code>：指令所在元素被插入页面时调用。<br>
3)<code>update(element, binding)</code>：指令所在模板结构被重新解析时调用。<br>
4)<code>componentUpdated</code>指令所在组件的VNode及其子VNode全部更新后调用
5)<code>unbind</code>只调用一次，指令与元素解绑时调用</p></li> <li><p>回调函数的参数：</p> <div class="language-js extra-class"><pre class="language-js"><code>  element <span class="token comment">// 指令所绑定的元素，可直接操作DOM</span>
  <span class="token literal-property property">binding</span><span class="token operator">:</span><span class="token punctuation">{</span>
    name <span class="token comment">// 指令名，不含v-前缀</span>
    value <span class="token comment">// 绑定的值</span>
    oldValue <span class="token comment">// 绑定的旧值</span>
    expression <span class="token comment">// 字符串形式的指令表达式</span>
    arg <span class="token comment">// 传给指令的参数, 如v-bind:arg=&quot;&quot;中的arg</span>
    modifiers <span class="token comment">// 修饰符对象, 如v-bind.sync =&gt; {sync:true}</span>
  <span class="token punctuation">}</span>
  vnode <span class="token comment">// 生成的虚拟节点</span>
  oldVnode <span class="token comment">// 上一个虚拟节点</span>
</code></pre></div></li> <li><p>备注：<br>
1.指令定义时不加v-，但使用时要加v-；<br>
2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。<br>
3.指令绑定参数可以动态绑定</p></li></ol></li></ul> <div class="custom-block tip"><p class="custom-block-title">v-if指令应该注意的地方</p> <p><code>v-if</code>指定修饰的节点在条件变为不满足时，将摧毁该节点及其子节点；当条件再变为满足时，新创建的节点及子节点与原有节点不同；<br>
这点在echarts这类需要持有DOM实例进行渲染的库中，由于持有的旧DOM实例与新节点的DOM实例不同，会出现不能渲染的情况，解决方案是在此类场景中使用<code>v-show</code>或重新获取新节点DOM并初始化echarts实例<br> <code>v-if</code>与<code>v-else-if</code>等条件语句之间还存在着直接子节点复用的情况，添加key值可避免复用的情况发生<br>
总结下来高频切换用<code>v-show</code>，否则用<code>v-if</code><br>
另外<code>v-if</code>不推荐与<code>v-for</code>一起使用，当处于同一节点时<code>v-for</code>优先级更高，<code>v-if</code>会作用于循环中的每一个item</p></div> <ul><li>v-model和v-bind.sync</li></ul> <p>两个指令均可实现双向绑定，即子组件改变prop时变化能同步到父组件中<br>
其中<code>v-bind.sync</code> 通过自定义事件事件，在子组件中使用<code>this.$emit('update:prop名称', newVal)</code>的方式触发反向更新<br> <code>v-bind.sync</code>不能与表达式一起使用，仅能提供property名<br>
v-bind.sync本质是语法糖</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>custom-component</span> <span class="token attr-name">:value.sync</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>custom-component</span><span class="token punctuation">&gt;</span></span>
相当于
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>custom-component</span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">@update:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value = $event<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>custom-component</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>v-model：v-model实际是v-bind.sync的语法糖，且每个组件仅能绑定一个v-model指令，对应text, textarea 的value属性反向更新绑定为input事件，而checkbox, select等为change事件,且仅能绑定到这些标签对应的固定值上<br>
在自定义组件中使用需要通过model选项定制其prop和event，否则默认事件为input<br>
在自定义组件中使用需要通过model选项定制其prop和event，否则默认事件为input，默认绑定prop为value</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">model</span><span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token literal-property property">prop</span><span class="token operator">:</span> <span class="token string">'props name'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">event</span><span class="token operator">:</span> <span class="token string">'change'</span> <span class="token comment">// set default input event to change event</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token string-property property">'props name'</span><span class="token operator">:</span> String
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>ps:在vue3中v-model的使用范围已和v-bind.sync相同，并且移除了v-bind的sync修饰符<br> <a href="https://v3.cn.vuejs.org/guide/migration/v-model.html#%E6%A6%82%E8%A7%88" target="_blank" rel="noopener noreferrer">参考文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h2> <p><img src="/assets/img/lifecycle.6f2c97f0.png" alt="lifecycle"></p> <ul><li><p>常用的生命周期钩子：<br>
1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。<br>
2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</p></li> <li><p>关于销毁Vue实例<br>
1.销毁后借助Vue开发者工具看不到任何信息。<br>
2.销毁后自定义事件会失效，但原生DOM事件依然有效。<br>
3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</p></li> <li><p>父子组件生命周期执行顺序</p> <ol><li>加载过程：父组件beforeCreate =&gt; 父组件created =&gt; 父组件beforeMount =&gt; 子组件beforeCreate =&gt; 子组件created =&gt; 子组件 beforeMount =&gt; 子组件mounted =&gt; 父组件mounted</li> <li>更新过程：父组件beforeUpdate =&gt; 子组件beforeUpdate =&gt; 子组件updated =&gt; 父组件updated</li> <li>销毁过程：父组件beforeDestroy =&gt; 子组件 beforeDestroy =&gt; 子组件 destroyed =&gt; 父组件 destroyed</li></ol></li></ul> <h2 id="组件化编程"><a href="#组件化编程" class="header-anchor">#</a> 组件化编程</h2> <p>Vue中使用组件的三大步骤：</p> <ul><li><p>一、定义一个组件<br>
使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；<br>
1.编写组件时不挂载元素,因此不写el属性<br>
2.data必须写成函数形式,便于组件实例化时每次都生成新的数据对象<br>
3.在脚手架中推荐在options对象中使用name属性，其值命名多单词组成时可使用大驼峰(推荐方式,需在脚手架环境下)或<code>-</code>连字符的方式<br>
4.组件文件名命名推荐与name属性保持一致<br>
备注：使用template可以配置组件结构。<br>
全局定义组件时可简写:<code>const school = Vue.extend(options) =&gt; const school = options</code></p></li> <li><p>二、注册组件<br>
1.局部注册：靠new Vue的时候传入components选项<br>
2.全局注册：靠Vue.component('组件名',组件)</p></li> <li><p>三、使用组件标签：<br>
闭合标签和自闭合标签(需脚手架环境)均可,vue解析标签时实例化vue组件对象</p></li> <li><p>四、组件与vm之间的关系<br>
内置关系：<code>VueComponent.prototype.__proto__ === Vue.prototype</code></p></li></ul> <p>组件化编程中main.js文件中用于创建vm,唯一实例化的vue对象作为入口挂载组件,App.vue文件中定义根组件容器用于管理其它组件</p> <p>ps：构造函数的prototype显式原型属性与其实例化后的实例的__proto__隐式原型属性指向同一个原型对象</p> <ul><li><p>组件的函数式调用<br>
通过在父组件的生命周期中调用函数，从而使用子组件的方式。适合于简单组件如非模态的弹窗消息、loading遮罩等
定义方式示例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> MyMessage <span class="token keyword">from</span> <span class="token string">'MyMessage.vue'</span><span class="token punctuation">;</span> <span class="token comment">// 以函数式调用的组件</span>
<span class="token keyword">const</span> MsgCreator <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span>MyMessage<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 生成MyMessage组件构造函数</span>
<span class="token keyword">function</span> <span class="token function">createMessage</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> props<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> MsgVM <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MsgCreator</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 实例化组件此时可传入props数据,并使用$mount函数生成DOM</span>
  <span class="token comment">// 在此函数中还可通过事件监听、设置el等方式添加更多功能</span>
  el<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>MsgVM<span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 操作DOM将组件追加到传入的el子元素末尾</span>
  <span class="token keyword">return</span> MsgVM <span class="token comment">// 返回MsgVM实例以便功能扩展</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span>createMessage<span class="token punctuation">}</span>  <span class="token comment">// 暴露函数，调用方引入该函数并调用即可使用MyMessage组件</span>
</code></pre></div></li> <li><p>动态组件<code>&lt;component&gt;</code></p></li></ul> <p>vue内置元素<code>&lt;component v-bind:is=&quot;switchComponentName&quot;&gt;</code>通过<code>is</code>prop绑定已注册的组件名或组件的选项对象switchComponentName上，组件名也可用于普通的html标签，但普通标签的value等property需要使用<code>.prop</code>修饰器修饰，否则功能异常<br>
TODO：完善动态组件的更详细的使用方法</p> <ul><li>递归组件</li></ul> <p>即组件在自己的模板中引用自身，此时要求组件有name选项或在全局注册<br>
编写递归组件时需要保证递归终止条件，否则会导致栈溢出max stack size exceeded错误</p> <ul><li>组件间循环引用</li></ul> <p>组件间的循环引用在打包时就会形成引用悖论，引发编译错误，解决此问题有如下方式：</p> <ol><li>全都进行全局注册</li> <li>在首先引用的那个组件A中通过beforeCreate生命周期钩子进行引入注册<code>beforeCreate(){ this.$options.components.yourComponent = require('url'); }</code></li> <li>注册组件时使用异步<code>() =&gt; import('url')</code>的方式注册</li></ol> <ul><li>函数式组件(无状态无实例)</li></ul> <p>组件内部没有管理任何状态，没有生命周期，也没有实例(没有this上下文), 仅接收一些props，类似于函数，因此可以设置functional属性<code>&lt;template functional&gt;</code>或<code>Vue.component('myComponent', {functional:true})</code>，将该组件变为一个函数式组件</p> <p>函数式组件若是写成渲染函数的形式，则其render 函数接收第二个参数context作为上下文，context对象包含props, children, slots, scopedSlots, data(传递给组件的整个数据对象区别与普通组件的data选项，此处还包含data.no, data.attrs等), parent, listeners(data.on的别名), injections</p> <p>前面有介绍组件的函数式调用，其本质仍然是普通组件，这是其与函数式组件最大的区别</p> <p>函数式组件本质是一个函数，与之对应的是普通的类组件，其渲染开销低于类组件。通常用于包装子组件，在将children，props，data传递给子组件前操作这些属性</p> <h2 id="组件间通信的方式"><a href="#组件间通信的方式" class="header-anchor">#</a> 组件间通信的方式</h2> <ul><li>props &amp; emit</li></ul> <p>props/emit仅适用于父子组件间通信，<a href="#%E7%BB%84%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%8F%8A%E9%85%8D%E7%BD%AE">props属性</a>只能从父组件单向流向子组件。<br>
要实现双向通信需配合自定义事件emit, 在父组件使用v-on绑定监听事件回调函数，在子组件中使用this.$emit触发对应事件，并回传相应参数即可实现子组件到父组件的数据流动。<br>
监听事件的回调函数上下文最终还是父组件。</p> <div class="custom-block tip"><p class="custom-block-title">v-model和v-bind.sync</p> <p>这两个指令基于props和emit实现的双向绑定也也可算作组件间通信的一种方式<br>
详见<a href="#%E6%8C%87%E4%BB%A4">指令</a>章节中的辨析</p></div> <ul><li>EventBus 事件总线(发布订阅模式)</li></ul> <p>基于自定义事件,普通自定义事件父组件通过v-on在子组件上订阅事件，并绑定回调函数，子组件中通过this.$emit触发对应事件并回传参数<br>
事件总线需要在全局注册发布者bus，一个组件中通过<code>bus.$emit('消息名', 传递参数)</code>发布消息，其他需要通信的组件通过<code>bus.$on('消息名', 回调函数(传递的参数))</code>订阅此消息。<br>
由于是全局对象，可以存在多个订阅者，组件间通信也不仅限于父子组件，任意组件间均可进行通信<br>
在组件销毁时需要通过<code>bus.$off('消息名', 回调函数)</code>的方式移除该事件的回调<br>
另外还有<code>$once</code>的方式监听事件对应回到函数仅执行一次</p> <ul><li>provide &amp; inject</li></ul> <p>provide/inject可以实现祖到孙组件间的通信,没有层级深度限制，且不会为数据增加额外的响应式(传入响应式数据则有响应式，没有则没有响应式)，<br>
祖组件中设置provide属性，提供可供注入的对象或返回对象的函数，子孙组件中使用inject属性(string[]/object)从提供的注入对象中选择要注入的属性。</p> <ul><li><code>$parent</code> &amp; <code>$children</code>或ref</li></ul> <p>利用<code>$parent</code>和<code>$children</code>属性获取父组件或子组件的实例，通过读取或操作对应的值即可实现父子组件间通信<br>
这种组件间通信方式仅应急状况下使用，不推荐大规模应用
PS: 与之相类似的还可通过<code>$root</code>访问到根实例</p> <ul><li><code>$attrs</code> &amp; <code>$listeners</code></li></ul> <p>该组合可进行祖孙组件间通信。<br> <code>$attrs</code>当前组件包含了除props声明外的所有绑定属性(class、style除外)，可以类比为函数中的<code>...rest</code>参数<br>
当前组件可通过<code>v-bind=&quot;$attrs&quot;</code>将其接收的绑定属性传递到其子组件上，从而让孙组件可以访问到祖组件上传入的绑定属性<br> <code>$listeners</code>与<code>$attrs</code>类似包含了v-on事件监听器(不含.native修饰的),同样使用<code>v-on=&quot;$listeners&quot;</code>可将接收的事件监听器传递到子组件中，让孙组件能够访问到事件，并通过<code>$emit</code>可触发该事件，并且当当前组件中额外绑定了同名事件时，孙组件会同时触发这两个事件，触发顺序类似于冒泡，因此尽量避免事件名重复</p> <ul><li>vuex</li></ul> <p>vuex是一个全局状态管理库，详细特性及使用方法见<a href="/vue/vuex/">vuex</a></p> <h2 id="脚手架"><a href="#脚手架" class="header-anchor">#</a> 脚手架</h2> <p>main.js文件中使用<code>render: h =&gt; h(App)</code>的原因是<br>
通过脚手架import的vue只包含核心功能没有模板解析器，因此不能使用template配置项，需要使用render函数接收到的createElement函数(简写为h)去指定具体内容<br>
render函数将App组件放入容器中</p> <h2 id="组件属性及配置"><a href="#组件属性及配置" class="header-anchor">#</a> 组件属性及配置</h2> <ul><li>ref属性</li></ul> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>School</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>sch<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>  
this.$refs.sch 可获取到真实的DOM元素或School组件实例对象  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>School</span><span class="token punctuation">&gt;</span></span>  
</code></pre></div><ul><li>props属性</li></ul> <p>props类似于函数的参数，数据由父传子单向传递，若要进行子传父，需父组件先传递回调函数，子组件通过调用回调函数的方式向父组件传递数据，在子组件中不推荐直接修改父组件传过来的props数据<br>
若在子组件中尝试修改传入的props，vue会在控制台抛出错误，但由于js的对象或数组等传递方式是传引用，因此若props属性是一个对象或数组，直接修改其内部属性则可以修改成功并影响父组件<br>
常用写法如下:</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// 在父组件中，使用v-bind传入name属性值data</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child-component</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>data<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child-component</span> <span class="token attr-name">v-bind</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>data<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span> <span class="token comment">// 传入整个data对象，data对象的key-value将对应props中定义的属性名，类似于函数的参数解构</span>

<span class="token keyword">var</span> childComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">//简单声明接收  </span>
  <span class="token literal-property property">props</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'age'</span><span class="token punctuation">,</span><span class="token string">'sex'</span><span class="token punctuation">]</span>  
  <span class="token comment">// 类型限制  </span>
  <span class="token literal-property property">props</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span>String<span class="token punctuation">}</span>  
  <span class="token comment">// 类型限制+默认值的指定+必要性的限制  </span>
  <span class="token literal-property property">props</span><span class="token operator">:</span><span class="token punctuation">{</span>  
    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token punctuation">{</span>  
      <span class="token literal-property property">type</span><span class="token operator">:</span>String<span class="token punctuation">,</span>  
      <span class="token literal-property property">required</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 与default属性二选一  </span>
      <span class="token comment">// default:'张三'  </span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>关联话题<a href="#%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F">组件间通信</a></p> <ul><li>mixin混入</li></ul> <p>将vue配置项的一部分提取出去,给各组件复用的方式称为混入;<br>
局部混入:通过import导入对象,在配置项中使用<code>mixins:[mixinObj1,mixinObj2]</code><br>
全局混入:全局混入将混入每一个vue实例中,导入后,通过<code>Vue.mixin(mixinObj1)</code>逐个混入<br>
混入的配置项若有重复,不会覆盖原配置,<br>
混入的对象型选项会进行合并，若key值冲突，则组件的属性值将覆盖该选项，hook函数则将合并调用，混入的hook优先被调用</p> <p>Vue.extend()也采用了同样的策略进行合并</p> <p>通过Vue.config.optionMergeStrategies.myOption可以自定义选项合并逻辑</p> <ul><li>插件</li></ul> <p>在实例化vm之前,调用<code>Vue.use(plugins,params)</code>的方式挂载插件,传入plugins对象中必须包含install方法,install可以接收到Vue构造函数和params参数,在此阶段全局过滤器,全局混入,第三方库等功能挂载到原型对象上,增加vue的功能</p> <ul><li>scoped</li></ul> <p>在vue文件中<code>&lt;styl scoped&gt;&lt;/style&gt;</code>中使用该属性,标签中的属性将只在本组件中生效.<br>
vue是通过将模板中的标签加入<code>data-生成数字</code>属性来约束样式的</p> <ul><li><code>$nextTick</code></li></ul> <p><code>$nextTick</code>属性用于传入一个回调函数,该函数在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM.<br> <code>$nextTick</code>也算是生命周期图之外的一个生命周期函数</p> <ul><li>过渡动画</li></ul> <p>vue中还支持使用标签<code>&lt;transition&gt;&lt;/transition&gt;</code>或<code>&lt;transition-group&gt;&lt;/transition-group&gt;</code>设置过渡效果,详见<a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener noreferrer">官方文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>vue-resource</li></ul> <p>vue-resource是vue1.×版本提供的ajax请求插件,vue2.0以后不再维护,推荐使用axios发起ajax请求</p> <h2 id="插槽"><a href="#插槽" class="header-anchor">#</a> 插槽</h2> <p>vue通过插槽向子组件中传递html结构<br>
由于结构是在父组件中定义的,所以结构的样式和数据也可引用父组件</p> <ul><li>默认插槽</li></ul> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 父组件中 --&gt;</span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>子组件</span><span class="token punctuation">&gt;</span></span>要插入的html结构<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>子组件</span><span class="token punctuation">&gt;</span></span>  
<span class="token comment">&lt;!-- 子组件中 --&gt;</span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">&gt;</span></span>默认值/结构<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 要插入的html结构占位符 --&gt;</span>  
</code></pre></div><ul><li>具名插槽</li></ul> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 父组件中 --&gt;</span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>子组件</span><span class="token punctuation">&gt;</span></span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>占位1</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 要插入占位1中的结构，v-slot指令仅可用于template标签上(被提供的内容仅有默认插槽时除外) --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>占位2</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 要插入占位2中的结构 --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>子组件</span><span class="token punctuation">&gt;</span></span>  
<span class="token comment">&lt;!-- 子组件中 --&gt;</span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>占位1<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>默认值/结构<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>占位2<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>默认值/结构<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>  
</code></pre></div><ul><li>作用域插槽</li></ul> <p>父级模板中的所有内容都是在父级作用域中编译的；子组件的模板则时在子级作用域的中编译，因此要插入的html结构想要访问子组件中的变量，需要用到作用域插槽</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 父组件中 --&gt;</span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>childrenParams<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!-- 将接收自子组件的变量重命名为了childrenParams --&gt;</span>  
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html结构</span><span class="token punctuation">&gt;</span></span>{{childrenParams.params1}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html结构</span><span class="token punctuation">&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>  
<span class="token comment">&lt;!-- 子组件中 --&gt;</span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">:params1</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>data1<span class="token punctuation">&quot;</span></span> <span class="token attr-name">params2</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>js表达式<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 可传递多个参数，将被包裹在一个对象中 --&gt;</span>  
</code></pre></div><p>另外可以通过<code>&lt;template v-slot:[动态插槽名]&gt;&lt;/template&gt;</code>的方式定义动态的插槽名<br>
具名插槽中<code>v-slot:</code>在<code>:</code>后有参数时<code>v-slot:</code>部分可缩写为<code>#</code></p> <h2 id="动态组件和异步组件"><a href="#动态组件和异步组件" class="header-anchor">#</a> 动态组件和异步组件</h2> <p>动态切换的组件上，想要保持组件的状态可以使用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>包裹，能够避免创建组件，能够在频繁切换的场景下提升性能<br>
异步组件即以工厂函数的方式定义组件，工厂函数会异步的解析组件定义，vue仅在需要渲染时才会触发工厂函数，并且会缓存结果供未来重新渲染<br>
异步组件最常见的使用形式是与webpack的code split功能相结合，通过类似<code>() =&gt; import('./my-async-component')</code>的方式进行注册或导入，从而增强code split的效果，将应用切分成更小的代码块</p> <h2 id="过渡"><a href="#过渡" class="header-anchor">#</a> 过渡</h2> <p>vue在插入、更新、移除DOM或组件时提供不同的方式应用过渡效果，主要方式有：</p> <ul><li>在 CSS 过渡和动画中自动应用 class，配合使用第三方 CSS 动画库，如 Animate.css</li> <li>在过渡钩子函数中使用 JavaScript 直接操作 DOM，配合使用第三方 JavaScript 动画库，如 Velocity.js</li></ul> <p>通过在<code>&lt;transition&gt;</code>上绑定hook可直接操作DOM自定义过渡效果，hook绑定支持8种:</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition</span>
  <span class="token attr-name"><span class="token namespace">v-on:</span>before-enter</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(el) =&gt; {}<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">v-on:</span>enter</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(el, done) =&gt; {done()}<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">v-on:</span>after-enter</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(el) =&gt; {}<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">v-on:</span>enter-cancelled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(el) =&gt; {}<span class="token punctuation">&quot;</span></span>

  <span class="token attr-name"><span class="token namespace">v-on:</span>before-leave</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(el) =&gt; {}<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">v-on:</span>leave</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(el, done) =&gt; {done()}<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">v-on:</span>after-leave</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(el) =&gt; {}<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">v-on:</span>leave-cancelled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(el) =&gt; {}<span class="token punctuation">&quot;</span></span>
<span class="token punctuation">&gt;</span></span>实际使用过程中推荐使用function的形式绑定
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ul><li>使用vue封装的<code>&lt;transition&gt;&lt;/transition&gt;</code>组件包裹需要动画的标签或组件，这些标签或组件通常需要设置动态状态如:v-if、v-show、动态组件或组件根节点等</li></ul> <p>当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理：</p> <p>自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。<br>
主要包含6个类名:
v-enter, v-enter-active, v-enter-to;v-leave, v-leave-active, v-leave-to;
各类名对应的状态及顺序详见<a href="https://v2.cn.vuejs.org/v2/guide/transitions.html#%E8%BF%87%E6%B8%A1%E7%9A%84%E7%B1%BB%E5%90%8D" target="_blank" rel="noopener noreferrer">官方文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br>
若<code>&lt;transition&gt;</code>中设置了name属性，则类名前缀<code>v</code>会被替换为name属性值,设置<code>类名-class</code>的属性则可自定义过渡的类名，设置duration属性则可定制持续时间</p> <p>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和 Vue 的 nextTick 概念不同)</p> <ul><li>初始渲染的过渡</li></ul> <p>通过appear属性设置节点在初始渲染的过渡，与默认的进入离开过渡一样也可以自定义类名与绑定hook</p> <ul><li>多个元素过渡(元素切换)</li></ul> <p>当元素切换时(通过v-if/v-else或<code>&lt;component&gt;</code>等方式)，一个离开过渡的时候另一个开始进入过渡，同时生效的过渡不能满足所有要求，vue的过渡模式提供了in-out属性：新元素先进行过渡，完成之后当前元素过渡离开;out-in：当前元素先进行过渡，完成之后新元素过渡进入;两种模式</p> <ul><li>列表过渡</li></ul> <p>列表过渡适用于使用了v-for指令的元素组，需要使用<code>&lt;transition-group&gt;</code>组件包裹，组件会转换为真实DOM，默认为<code>&lt;span&gt;</code>标签，且过渡模式不可用，内部元素需要指定唯一的key，css过渡的类会应用于内部元素中而不是组或容易本身<br>
列表过渡的类名在普通过渡的基础上增加了move用于改变定位时使用</p> <p>PS：将<code>&lt;transition-group&gt;</code>或<code>&lt;transition&gt;</code>作为根组件进行封装能够对过渡效果进行复用，更推荐使用函数式组件的方式进行复用</p> <ul><li>状态过渡</li></ul> <p>组件中的状态，如节点位置，颜色显示，大小位置等其他属性发生变化可以利用响应式特性和组件结合一些css/js动效库，实现状态切换的过渡</p> <h2 id="渲染函数与jsx"><a href="#渲染函数与jsx" class="header-anchor">#</a> 渲染函数与jsx</h2> <p><code>.vue</code>文件中的<code>&lt;template&gt;</code>经过模板编译阶段会生成render渲染函数，调用render会得到对应的虚拟DOM。<br>
通过编写render函数跳过模板编译阶段，从而获得更大的模板灵活性，但同时也要求对底层api较为熟悉<br>
在vue的options配置项中加入render选项:</p> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'myComponent'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">createElement</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">createElement</span><span class="token punctuation">(</span>
      <span class="token comment">// 添加render属性，使用createElement函数生成并返回虚拟DOM </span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>createElement函数的入参</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">tagName</span><span class="token operator">:</span> string<span class="token operator">|</span> object <span class="token operator">|</span> Function <span class="token comment">// 必填项，标签名或组件选项对象</span>
<span class="token literal-property property">attributeObject</span><span class="token operator">:</span><span class="token punctuation">{</span> <span class="token comment">// 可选，与模板中attribute对应的数据对象</span>
  <span class="token string-property property">'class'</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token literal-property property">foo</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token literal-property property">bar</span><span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 与v-bind:class api相同</span>
  <span class="token string-property property">'style'</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token literal-property property">color</span><span class="token operator">:</span><span class="token string">'red'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 与v-bind:style api相同</span>
  <span class="token literal-property property">attrs</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 普通attribute</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 组件props属性</span>
  <span class="token literal-property property">domProps</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token literal-property property">innerHTML</span><span class="token operator">:</span><span class="token string">'baz'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// DOM properties</span>
  <span class="token literal-property property">on</span><span class="token operator">:</span><span class="token punctuation">{</span> <span class="token literal-property property">click</span><span class="token operator">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>clickHandler<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// v-on绑定的事件监听器</span>
  <span class="token literal-property property">nativeOn</span><span class="token operator">:</span><span class="token punctuation">{</span> <span class="token literal-property property">click</span><span class="token operator">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>nativeClickHandler<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 仅用于组件，监听原生事件</span>
  <span class="token literal-property property">directives</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 自定义的指令</span>
  <span class="token literal-property property">scopedSlots</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token function-variable function">default</span><span class="token operator">:</span><span class="token parameter">props</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 作用于插槽</span>
  <span class="token literal-property property">slot</span><span class="token operator">:</span> <span class="token string">'name-of-slot'</span><span class="token punctuation">,</span> <span class="token comment">// 作为子组件时，指定的插槽名称</span>
  <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
  <span class="token literal-property property">ref</span><span class="token operator">:</span> string<span class="token operator">|</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 若给多个元素都应用了相同的ref名，则会变成一个数组</span>
  <span class="token literal-property property">refInFot</span><span class="token operator">:</span> <span class="token boolean">true</span>

<span class="token punctuation">}</span>
<span class="token literal-property property">childNode</span><span class="token operator">:</span> string <span class="token operator">|</span> Array <span class="token comment">// 文本节点或子级虚拟节点需要由createElement函数生成</span>
</code></pre></div><p>PS:VNode必须唯一，因此多个相同的VNode需要用工行函数实现<br>
渲染函数中v-if/v-for可以用条件判断或map等方式实现，而v-model语法糖则需要自行实现相关逻辑<br>
对于部分事件修饰符，提供了对应的修饰前缀，如<code>click.passive =&gt; &amp;click; click.capture =&gt; !click; click.once =&gt; ~click</code>,而其他修饰符基本可以从event参数中读取到并操作，因此没有对应的修饰符<br>
通过this.$slots可以访问静态插槽的内容, 通过this.$scopedSlots访问作用于插槽</p> <ul><li>jsx</li></ul> <p>jsx风格的语法允许在js文件中直接书写xml风格的template语法，因此可以借助构建loader，用于代替上述createElement的函数式调用风格，如:</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token punctuation">{</span> <span class="token comment">// 省略了其他配置项</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">AnchoredHeading</span></span> <span class="token attr-name">level</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Hello</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token plain-text"> world!
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">AnchoredHeading</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><hr> <h2 id="cookbook"><a href="#cookbook" class="header-anchor">#</a> Cookbook</h2> <p>参考资料<a href="https://cn.vuejs.org/v2/cookbook/" target="_blank" rel="noopener noreferrer">Cookbook<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中主要介绍了vue的编程技巧</p> <h2 id="添加实例property"><a href="#添加实例property" class="header-anchor">#</a> 添加实例property</h2> <p><code>vue.prototype.$appName = 'My App'</code>其中$符号是为了避免命名冲突而约定的符号。
当在原型时绑定自定义函数时，该函数通过this，能够访问到实例的作用域。
为了保证安全，应尽量避免使用该模式</p> <h2 id="表单校验"><a href="#表单校验" class="header-anchor">#</a> 表单校验</h2> <h2 id="vue-cli"><a href="#vue-cli" class="header-anchor">#</a> vue-cli</h2> <p>vue-cli是基于webpack等打包工具的</p> <h3 id="vue-lib模式打包生成umd文件笔记"><a href="#vue-lib模式打包生成umd文件笔记" class="header-anchor">#</a> vue lib模式打包生成umd文件笔记</h3> <p>通过使用vue<a href="https://cli.vuejs.org/zh/guide/build-targets.html#%E5%BA%93" target="_blank" rel="noopener noreferrer">打包命令<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中的target参数 指定构建模式为lib，可打包生产umd文件。<br>
lib模式下默认不会打包vue，若要打包vue可使用命令<code>vue-cli-service build --target lib --inline-vue</code>
打包完成后可生成文件<br>
×××.common.js: 一个给打包器用的 CommonJS 包 (不幸的是，webpack 目前还并没有支持 ES modules 输出格式的包)<br>
×××.umd.js: 一个直接给浏览器或 AMD loader 使用的 UMD 包<br>
×××.umd.min.js: 压缩后的 UMD 构建版本<br>
×××.css: 提取出来的 CSS 文件 (可以通过在 vue.config.js 中设置css: { extract: false } 强制内联)</p> <h2 id="关联问题js模块化历史"><a href="#关联问题js模块化历史" class="header-anchor">#</a> 关联问题js模块化历史</h2> <ol><li>立即执行函数<br>
通过立即执行函数封装一个局部作用域</li> <li>CommonJS标准<br>
nodejs出现后为了解决打包文件相互依赖问题，出现了commonjs语法
引入使用var fs = require('fs'), 导出使用module.export a = 1;</li> <li>AMD(异步模块定义)<br>
Commonjs是同步执行，但浏览器经常需要异步加载资源，于是有了AMD的语法，通过回调方式拿到异步变量 require('vue', (Vue) =&gt; {new Vue();})</li> <li>import/export<br>
为了统一2、3两种方式js委员会发布了标准的import/export语法，通过import导入模块，export导出模块。同时，这种打包方式能够更好的在编译时进行静态优化
这种标准随之es6标准一起出现，因此也称这种模块为es6模块</li></ol> <p>UMD(统一模块定义):这种模块语法会自动监测开发人员使用的是 Common.js/AMD/import/export 种的哪种方式，然后再针对各自的语法进行导出，这种方式可以兼容所有其他的模块定义方法。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">8/15/2022, 12:30:14 AM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.996fe2d2.js" defer></script><script src="/assets/js/2.84daa104.js" defer></script><script src="/assets/js/15.4de3e399.js" defer></script>
  </body>
</html>
