<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.15" />
    <style>
      :root {
        --c-bg: #fff;
      }

      html.dark {
        --c-bg: #22272e;
      }

      html,
      body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia('(prefers-color-scheme: dark)').matches

      if (userMode === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (userMode === 'dark' || systemDarkMode) {
        document.documentElement.classList.toggle('dark', true)
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <link rel="icon" href="/img/cat.jpg"><title>vue2基础使用 | Vito's blog</title><meta name="description" content="vito的个人网站">
    <link rel="preload" href="/assets/style-BHfFXfh2.css" as="style"><link rel="stylesheet" href="/assets/style-BHfFXfh2.css">
    <link rel="modulepreload" href="/assets/app-CeNZkc-K.js"><link rel="modulepreload" href="/assets/vue2base.html-ChhltItm.js">
    <link rel="prefetch" href="/assets/guide.html-CgcQwnJ4.js" as="script"><link rel="prefetch" href="/assets/index.html-DL2K7sPH.js" as="script"><link rel="prefetch" href="/assets/10sortedAlgorithm.html-CtpJVuyE.js" as="script"><link rel="prefetch" href="/assets/common.html-DoKcd709.js" as="script"><link rel="prefetch" href="/assets/index.html-BbA3_tCo.js" as="script"><link rel="prefetch" href="/assets/labuladongNote.html-C0QsjLvZ.js" as="script"><link rel="prefetch" href="/assets/leetcode100.html-DhWeFuqX.js" as="script"><link rel="prefetch" href="/assets/python_sword_for_offer.html-BrXLTYDB.js" as="script"><link rel="prefetch" href="/assets/tsClassicTop10SortAlgorithm.html-tLjZgv1G.js" as="script"><link rel="prefetch" href="/assets/tsSword4Offer.html-C7XPsKXc.js" as="script"><link rel="prefetch" href="/assets/browser.html-CXp6XHFF.js" as="script"><link rel="prefetch" href="/assets/index.html-zl5S2Mpj.js" as="script"><link rel="prefetch" href="/assets/index.html-Hj3hbXeG.js" as="script"><link rel="prefetch" href="/assets/index.html-DQ7Nzgd1.js" as="script"><link rel="prefetch" href="/assets/npm-note.html-5MID8l4x.js" as="script"><link rel="prefetch" href="/assets/html5.html-DDZeFEz0.js" as="script"><link rel="prefetch" href="/assets/html进阶.html-BtEzlC7Z.js" as="script"><link rel="prefetch" href="/assets/index.html-BFX874Mr.js" as="script"><link rel="prefetch" href="/assets/longList.html-l5jYbOpC.js" as="script"><link rel="prefetch" href="/assets/webSafe.html-DZgqA0F8.js" as="script"><link rel="prefetch" href="/assets/abstract.html-DKLd4U2P.js" as="script"><link rel="prefetch" href="/assets/auto-app.html-R7CvFRQp.js" as="script"><link rel="prefetch" href="/assets/wechat-miniAppBase.html-DW1AdzRl.js" as="script"><link rel="prefetch" href="/assets/jsBase.html-eOaeN7lo.js" as="script"><link rel="prefetch" href="/assets/jsHand.html-DGqmHrVc.js" as="script"><link rel="prefetch" href="/assets/jsPlus.html-CclcHLIp.js" as="script"><link rel="prefetch" href="/assets/gitUseNote.html-BIisLNNb.js" as="script"><link rel="prefetch" href="/assets/index.html-CsNZApn0.js" as="script"><link rel="prefetch" href="/assets/UbuntuUsingNode.html-Dikp63o3.js" as="script"><link rel="prefetch" href="/assets/小新pro14ACH安装Ubuntu并美化.html-BcXIhNWc.js" as="script"><link rel="prefetch" href="/assets/qiankun.html-E6ku2ufk.js" as="script"><link rel="prefetch" href="/assets/axios.html-C7b-U6_Y.js" as="script"><link rel="prefetch" href="/assets/index.html-DnKeQcni.js" as="script"><link rel="prefetch" href="/assets/webNetwork.html-BYMdVjEU.js" as="script"><link rel="prefetch" href="/assets/express.html-CGJ1FY1G.js" as="script"><link rel="prefetch" href="/assets/koa基础.html-DFhCcWTt.js" as="script"><link rel="prefetch" href="/assets/next.html-BmhJcWhi.js" as="script"><link rel="prefetch" href="/assets/index.html-5Zub2w5A.js" as="script"><link rel="prefetch" href="/assets/react-base.html-DH--w71Z.js" as="script"><link rel="prefetch" href="/assets/index.html-B-1d7nDB.js" as="script"><link rel="prefetch" href="/assets/伯恩斯新情绪疗法.html-BP59cyyx.js" as="script"><link rel="prefetch" href="/assets/伯恩斯新情绪疗法2.html-C8rYZjWd.js" as="script"><link rel="prefetch" href="/assets/伯恩斯新情绪疗法3.html-BaEypgPm.js" as="script"><link rel="prefetch" href="/assets/依恋的形成.html-BUcWi-hw.js" as="script"><link rel="prefetch" href="/assets/穷查理宝典读书笔记.html-By_-bYB_.js" as="script"><link rel="prefetch" href="/assets/index.html-CvtS50hk.js" as="script"><link rel="prefetch" href="/assets/index.html-B68xQF_I.js" as="script"><link rel="prefetch" href="/assets/Pinia.html-BR2QXUQK.js" as="script"><link rel="prefetch" href="/assets/vue3plus.html-ZOtmVc8D.js" as="script"><link rel="prefetch" href="/assets/webpack5Note.html-D_-XH4yv.js" as="script"><link rel="prefetch" href="/assets/webpackNote.html-B7DDAQpT.js" as="script"><link rel="prefetch" href="/assets/index.html-DSVAhMnw.js" as="script"><link rel="prefetch" href="/assets/index.html-BvLTeL3t.js" as="script"><link rel="prefetch" href="/assets/index.html-Bj1fZyuh.js" as="script"><link rel="prefetch" href="/assets/index.html-CckZqZjo.js" as="script"><link rel="prefetch" href="/assets/index.html-BlL2QMrt.js" as="script"><link rel="prefetch" href="/assets/index.html-DzMRDiFW.js" as="script"><link rel="prefetch" href="/assets/index.html-DuB_U9jK.js" as="script"><link rel="prefetch" href="/assets/additionalInfo.html-CEn-waCM.js" as="script"><link rel="prefetch" href="/assets/guide.html-D-IiWui-.js" as="script"><link rel="prefetch" href="/assets/index.html-Dro_Zdx6.js" as="script"><link rel="prefetch" href="/assets/orgin.html-BcJge6ql.js" as="script"><link rel="prefetch" href="/assets/outputGuide.html-kHU6GPqL.js" as="script"><link rel="prefetch" href="/assets/guide.html-CJ_mrklV.js" as="script"><link rel="prefetch" href="/assets/mustache.html-Cv5VScm7.js" as="script"><link rel="prefetch" href="/assets/reactive.html-CawsvWYO.js" as="script"><link rel="prefetch" href="/assets/index.html-mHZSjXvV.js" as="script"><link rel="prefetch" href="/assets/vDom.html-DPSthvZk.js" as="script"><link rel="prefetch" href="/assets/index.html-D5I7MzzF.js" as="script"><link rel="prefetch" href="/assets/index.html-CMyy_JaO.js" as="script"><link rel="prefetch" href="/assets/index.html-DHoUUYOa.js" as="script"><link rel="prefetch" href="/assets/404.html-Bh-jMs9h.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon"><!--[--><header class="vp-navbar"><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/"><!----><span class="vp-site-name" aria-hidden="true">Vito&#39;s blog</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="JavaScript"><span class="title">JavaScript</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="JavaScript"><span class="title">JavaScript</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/js/jsBase.html" aria-label="js基础"><!---->js基础<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/js/es6_/" aria-label="es6+基础"><!---->es6+基础<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/js/jsPlus.html" aria-label="js进阶"><!---->js进阶<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/js/jsHand.html" aria-label="js手写系列"><!---->js手写系列<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/js/typescript/" aria-label="typescript"><!---->typescript<!----></a></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>js读书笔记</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/js/jsAsync/" aria-label="js异步编程"><!---->js异步编程<!----></a></li><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/js/jsDeep/" aria-label="你不知道的js系列"><!---->你不知道的js系列<!----></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Vue"><span class="title">Vue</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Vue"><span class="title">Vue</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/vue/vue2base.html" aria-label="vue2基础"><!---->vue2基础<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/vue/vue2plus/" aria-label="vue2进阶"><!---->vue2进阶<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/vue/vue3base/" aria-label="vue3基础"><!---->vue3基础<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/vue/vuex/" aria-label="vuex"><!---->vuex<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/vue/vueRouter/" aria-label="vue router"><!---->vue router<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/vue/Pinia.html" aria-label="pinia"><!---->pinia<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/html/" aria-label="html"><!---->html<!----></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="css"><span class="title">css</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="css"><span class="title">css</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/css/css3/" aria-label="图解css3"><!---->图解css3<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/css/css3plus/" aria-label="css进阶"><!---->css进阶<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/css/scss/" aria-label="scss"><!---->scss<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/browser/browser.html" aria-label="浏览器"><!---->浏览器<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/network/webNetwork.html" aria-label="网络通信"><!---->网络通信<!----></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Linux"><span class="title">Linux</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Linux"><span class="title">Linux</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/linuxNote/gitUseNote.html" aria-label="git使用笔记"><!---->git使用笔记<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/linuxNote/UbuntuUsingNode.html" aria-label="linux使用记录"><!---->linux使用记录<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="开发构建工具"><span class="title">开发构建工具</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="开发构建工具"><span class="title">开发构建工具</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/devToolsNote/npm-note.html" aria-label="npm"><!---->npm<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/webpack/webpackNote.html" aria-label="webpack基础"><!---->webpack基础<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/webpack/webpack5Note.html" aria-label="webpack5"><!---->webpack5<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/micro-app/qiankun.html" aria-label="qiankun"><!---->qiankun<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="算法"><span class="title">算法</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="算法"><span class="title">算法</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/algorithm/tsClassicTop10SortAlgorithm.html" aria-label="排序算法"><!---->排序算法<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/algorithm/tsSword4Offer.html" aria-label="剑指offer"><!---->剑指offer<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/algorithm/common.html" aria-label="常见算法"><!---->常见算法<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/algorithm/10sortedAlgorithm.html" aria-label="排序算法python"><!---->排序算法python<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/algorithm/python_sword_for_offer.html" aria-label="剑指offer-python"><!---->剑指offer-python<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/algorithm/labuladongNote.html" aria-label="labuladong算法"><!---->labuladong算法<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/vitotu" aria-label="github主页" rel="noopener noreferrer" target="_blank"><!---->github主页<!----></a></div><!--]--></nav><!--[--><!--]--><button class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar"><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="JavaScript"><span class="title">JavaScript</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="JavaScript"><span class="title">JavaScript</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/js/jsBase.html" aria-label="js基础"><!---->js基础<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/js/es6_/" aria-label="es6+基础"><!---->es6+基础<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/js/jsPlus.html" aria-label="js进阶"><!---->js进阶<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/js/jsHand.html" aria-label="js手写系列"><!---->js手写系列<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/js/typescript/" aria-label="typescript"><!---->typescript<!----></a></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>js读书笔记</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/js/jsAsync/" aria-label="js异步编程"><!---->js异步编程<!----></a></li><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/js/jsDeep/" aria-label="你不知道的js系列"><!---->你不知道的js系列<!----></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Vue"><span class="title">Vue</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Vue"><span class="title">Vue</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/vue/vue2base.html" aria-label="vue2基础"><!---->vue2基础<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/vue/vue2plus/" aria-label="vue2进阶"><!---->vue2进阶<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/vue/vue3base/" aria-label="vue3基础"><!---->vue3基础<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/vue/vuex/" aria-label="vuex"><!---->vuex<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/vue/vueRouter/" aria-label="vue router"><!---->vue router<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/vue/Pinia.html" aria-label="pinia"><!---->pinia<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/html/" aria-label="html"><!---->html<!----></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="css"><span class="title">css</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="css"><span class="title">css</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/css/css3/" aria-label="图解css3"><!---->图解css3<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/css/css3plus/" aria-label="css进阶"><!---->css进阶<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/css/scss/" aria-label="scss"><!---->scss<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/browser/browser.html" aria-label="浏览器"><!---->浏览器<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/network/webNetwork.html" aria-label="网络通信"><!---->网络通信<!----></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Linux"><span class="title">Linux</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Linux"><span class="title">Linux</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/linuxNote/gitUseNote.html" aria-label="git使用笔记"><!---->git使用笔记<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/linuxNote/UbuntuUsingNode.html" aria-label="linux使用记录"><!---->linux使用记录<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="开发构建工具"><span class="title">开发构建工具</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="开发构建工具"><span class="title">开发构建工具</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/devToolsNote/npm-note.html" aria-label="npm"><!---->npm<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/webpack/webpackNote.html" aria-label="webpack基础"><!---->webpack基础<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/webpack/webpack5Note.html" aria-label="webpack5"><!---->webpack5<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/micro-app/qiankun.html" aria-label="qiankun"><!---->qiankun<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="算法"><span class="title">算法</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="算法"><span class="title">算法</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/algorithm/tsClassicTop10SortAlgorithm.html" aria-label="排序算法"><!---->排序算法<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/algorithm/tsSword4Offer.html" aria-label="剑指offer"><!---->剑指offer<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/algorithm/common.html" aria-label="常见算法"><!---->常见算法<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/algorithm/10sortedAlgorithm.html" aria-label="排序算法python"><!---->排序算法python<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/algorithm/python_sword_for_offer.html" aria-label="剑指offer-python"><!---->剑指offer-python<!----></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/algorithm/labuladongNote.html" aria-label="labuladong算法"><!---->labuladong算法<!----></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/vitotu" aria-label="github主页" rel="noopener noreferrer" target="_blank"><!---->github主页<!----></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">vue2基础使用 <!----></p><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h1 id="vue2基础使用" tabindex="-1"><a class="header-anchor" href="#vue2基础使用"><span>vue2基础使用</span></a></h1><p>本文参考了官方文档及参考尚硅谷的vue2教程, 适合于刚上手vue的新手学习<br> 仅总结使用要点，对于基础语法部分参看<a href="https://v2.cn.vuejs.org/v2/guide/" target="_blank" rel="noopener noreferrer">官网文档</a>学习</p><h2 id="模板语法" tabindex="-1"><a class="header-anchor" href="#模板语法"><span>模板语法</span></a></h2><p>vue的<code>.vue</code>文件是SFC(Single File Components 单文件组件)风格的编码，即一个文件中包含了html,js,css三部分对应<code>&lt;template&gt;</code>，<code>&lt;script&gt;</code>，<code>&lt;style&gt;</code>，详细如下：</p><div class="language-vue line-numbers-mode" data-highlighter="prismjs" data-ext="vue" data-title="vue"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token comment">&lt;!-- 在这里书写html及模板语法</span>
<span class="line">此部分将通过@vue/complier-dom的处理，预编译为js的渲染函数render</span>
<span class="line">template本身最终将不会被渲染为DOM结构，并且内部可以多层嵌套template --&gt;</span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"></span>
<span class="line"><span class="token comment">// 在这里书写js</span></span>
<span class="line"></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css"></span>
<span class="line"><span class="token comment">/* 在这里书写css */</span></span>
<span class="line"></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SFC有着内聚关注、作用域css，预编译模板避免运行编译开销、利于模块化等优点，但也必须使用构建工具<br> 与之对应的<code>.jsx</code>风格即是在js中书写xml格式语法用于表示html结构，vue想要使用jsx风格需要自己书写render函数<br> vue在<code>&lt;template&gt;</code>中书写<code>{ {js表达式}}</code>,<code>v-指令:参数=&#39;表达式&#39;</code>等语法样式，这些语法样式由Vue实例来解析。这种方式统称为模板语法</p><ul><li><code>{ { js表达式 }}</code>:插值语法，其中可以引用组件上的属性，js表达式运行于沙盒中，只能访问<a href="https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9" target="_blank" rel="noopener noreferrer">白名单</a>中的全局变量</li><li>标签/自定义组件上的attribute需要使用<a href="#%E6%8C%87%E4%BB%A4">指令</a>来进行绑定，2.6.0版本后参数支持以<code>[参数js表达式]</code>的形式通过js表达式指定动态参数</li></ul><h2 id="data配置项与响应式" tabindex="-1"><a class="header-anchor" href="#data配置项与响应式"><span>data配置项与响应式</span></a></h2><ul><li>data配置项</li></ul><p>在vm实例中data的配置项可以写成对象形式,但在组件中由于组件的复用特性,data对象必须写成回调函数的形式，如</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span> <span class="token comment">// 到处vue options配置项对象用于创建组件或页面</span></span>
<span class="line">  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token literal-property property">a</span><span class="token operator">:</span><span class="token string">&#39;value of a&#39;</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token comment">// 可直接读写data中定义的属性</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>浅析响应式</li></ul><p>Vue获取配置项中的data对象后,对data对象进行代理(深度遍历对象给属性添加getter,setter等),然后将改造后的data对象赋给vm实例的<code>_data</code>属性,同时覆盖原有的对象引用,伪代码表示如下:</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// data对象  </span></span>
<span class="line"><span class="token keyword">let</span> b <span class="token operator">=</span> a  </span>
<span class="line"><span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  </span>
<span class="line">  <span class="token literal-property property">data</span><span class="token operator">:</span>a <span class="token comment">// 省略其他配置项  </span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span>  </span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_data <span class="token operator">===</span> a<span class="token punctuation">)</span> <span class="token comment">// true  </span></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_data <span class="token operator">===</span> b<span class="token punctuation">)</span> <span class="token comment">// false  </span></span>
<span class="line"><span class="token comment">// 原有的对象引用a被覆盖了,因此不等于b对象  </span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从data配置项中返回的对象将都具有响应式，即当该数据被修改后所有引用到的地方都会被同步修改</p><ul><li>响应式基础特性 <ol><li>Vue2在组件实例上设置属性,代理访问data配置项中的数据(vm.key与vm._data.key同源).</li><li>data配置项中数组对象的响应式是通过数组包装Array类型的原生<code>push()</code>、<code>pop()</code>、<code>shift()</code>、<code>unshift()</code>、<code>splice()</code>、<code>sort()</code>、<code>reverse()</code>等函数来实现的，因此在修改数组类型的数据时，想要响应式的更新，各调用处需要使用数组方法来修改数组而不是直接使用索引。</li><li>data配置项中的对象都设置的了数据代理，新加的属性想要获得响应式，需要通过<code>Vue.set(target，propertyName/index，value)</code>方法或方法内<code>vm.$set(target，propertyName/index，value)</code>进行设置</li><li>特别注意：<code>Vue.set()</code>和<code>vm.$set()</code>不能给vm 或 vm的根数据对象 添加属性！！！</li></ol></li></ul><p>更深层次的响应式原理参见<a class="route-link" href="/vue/vue2plus/#%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%93%8D%E5%BA%94%E5%BC%8F">响应式原理</a></p><h2 id="计算属性computed与监听属性watch" tabindex="-1"><a class="header-anchor" href="#计算属性computed与监听属性watch"><span>计算属性computed与监听属性watch</span></a></h2><p>直接在模板语法中无法使用过于复杂的js表达式，computed属性可以用于解决此问题<br> 类似于属性的getter/setter，仅配置一个函数时默认为getter<br> 与methods中的方法相比，computed有基于响应式依赖进行缓存，只有依赖发生变化时才会重新求值，相对而言适用于计算量较大的场景<br> 与computed属性相比，watch属性是更通用的监听数据变化的方法，适用于当数据变化时需要执行异步或开销较大的操作时<br> 更多参见<a class="route-link" href="/vue/vue2plus/#computed%E5%8E%9F%E7%90%86">computed和watch原理</a></p><h2 id="根实例vm" tabindex="-1"><a class="header-anchor" href="#根实例vm"><span>根实例vm</span></a></h2><p>vm取名字&#39;mvvm&#39;模型中的最后两个字符vm;model(数据),view(视图html),view-model(视图模型之间的映射)</p><h2 id="事件处理" tabindex="-1"><a class="header-anchor" href="#事件处理"><span>事件处理</span></a></h2><p><code>v-on:事件名.修饰符=&quot;事件处理器&quot;</code>，v-no也可以缩写为@符号；<br> 事件名为html标签支持的事件click, input等或自定义组件中触发的事件名</p><ul><li><p>事件处理器</p><ul><li>内联事件处理器：内联js表达式，js表达式内通过$event手动访问event参数</li><li>方法事件处理器：组件上定义的方法属性名或路径，默认会传入event参数和组件中触发的额外参数</li></ul></li><li><p>Vue中的事件修饰符：</p><ol><li>.prevent：阻止默认事件（常用）；</li><li>.stop：阻止事件冒泡（常用）；</li><li>.once：事件只触发一次（常用）；</li><li>.capture：使用事件的捕获模式；</li><li>.self：只有event.target是当前操作的元素时才触发事件；</li><li>.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；与.prevent同时使用时.prevent会被忽略</li><li>.native: 使用浏览器原生事件</li></ol></li></ul><p>事件修饰符可以叠加，但会以从左到右顺序生效</p><ul><li><p>按键<code>v-on:[keyup/keydown等].[按键名]=&quot;&quot;</code></p><ol><li><p>Vue中常用的按键别名：<br> 回车 =&gt; enter<br> 删除 =&gt; delete (捕获“删除”和“退格”键)<br> 退出 =&gt; esc<br> 空格 =&gt; space<br> 换行 =&gt; tab (特殊，必须配合keydown去使用)<br> 上 =&gt; up<br> 下 =&gt; down<br> 左 =&gt; left<br> 右 =&gt; right</p></li><li><p>Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）</p></li><li><p>系统修饰键（用法特殊）：ctrl、alt、shift、meta<br> 1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。<br> 2).配合keydown使用：正常触发事件。</p></li><li><p>也可以使用keyCode去指定具体的按键（已被废弃）</p></li><li><p>Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名</p></li><li><p>.exact用于精确控制系统修饰符组合触发的事件(有且仅有该键被按下时触发)</p></li></ol></li><li><p>鼠标修饰符<br> .left<br> .right<br> .middle</p></li><li><p>自定义事件</p></li></ul><p>自定义事件也可用于父子组件通信<br> 标签中绑定自定义事件的方式:<br><code>&lt;MyComponent @自定义事件=&#39;处理函数&#39;/&gt;</code>或</p><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html" data-title="html"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyComponent</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&#39;</span>myComponent<span class="token punctuation">&#39;</span></span><span class="token punctuation">/&gt;</span></span>  </span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">  </span>
<span class="line">  <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>myComponent<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">&#39;自定义事件&#39;</span><span class="token punctuation">,</span> 处理函数<span class="token punctuation">)</span>   </span>
<span class="line">  <span class="token comment">// 触发后处理函数的调用方仍然是该组件,  </span></span>
<span class="line">  <span class="token comment">// 若采用箭头函数,则无法读取当前组件的实例this,因此推荐使用在methods中定义的函数  </span></span>
<span class="line">  <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>myComponent<span class="token punctuation">.</span><span class="token function">$once</span><span class="token punctuation">(</span><span class="token string">&#39;自定义事件a&#39;</span><span class="token punctuation">,</span> 处理函数<span class="token punctuation">)</span> <span class="token comment">// 仅触发一次  </span></span>
<span class="line"></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>被绑上自定义事件的子组件可触发对应的事件并回传数据,如:<code>this.$emit(&#39;自定义事件a&#39;,params)</code></p><p>子组件在被销毁前需在beforeDestroy生命周期函数中进行解绑自定义事件<code>beforeDestroy(){this.$off(String单个事件|Array多个事件|不传参默认所有事件)}</code></p><ul><li>事件总线</li></ul><p>由于直接使用自定义事件在组件直接进行通讯有局限性,事件总线通过在vue原型上绑定vue根实例vm作为公共组件<code>$bus</code>,在<code>$bus</code>上绑定和触发事件来实现任意组件间的通信,如下代码</p><div class="language-JavaScript line-numbers-mode" data-highlighter="prismjs" data-ext="JavaScript" data-title="JavaScript"><pre><code><span class="line">// 原型上$bus绑定根实例vm  </span>
<span class="line">new Vue({  </span>
<span class="line"> el:&#39;#app&#39;,  </span>
<span class="line"> render: h =&gt; h(App),  </span>
<span class="line"> beforeCreate() {  </span>
<span class="line">  Vue.prototype.$bus = this //安装全局事件总线  </span>
<span class="line"> },  </span>
<span class="line">})  </span>
<span class="line">// 任意组件上绑定事件,解绑时请慎用解绑全部事件的写法  </span>
<span class="line">this.$bus.$on(&#39;hello&#39;,(data)=&gt;{  </span>
<span class="line">  console.log(&#39;我是School组件，收到了数据&#39;,data)  </span>
<span class="line">})  </span>
<span class="line">// 另一组件上触发  </span>
<span class="line">this.$bus.$emit(&#39;hello&#39;,this.name)  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与事件总线相类似的还有使用第三方库pubsub-js的消息发布订阅方式，用法与事件总线类似</p><h2 id="绑定样式与class" tabindex="-1"><a class="header-anchor" href="#绑定样式与class"><span>绑定样式与class</span></a></h2><ol><li>class样式<br> 写法<code>:class=&quot;xxx&quot;</code> xxx可以是字符串、对象、数组。<br> 字符串写法适用于：类名不确定，要动态获取。<br> 对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。<br> 数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</li><li>style样式<br><code>:style=&quot;{fontSize: xxx}&quot;</code>其中xxx是动态值。<br><code>:style=&quot;[a,b]&quot;</code>其中a、b是样式对象。</li></ol><h2 id="列表渲染" tabindex="-1"><a class="header-anchor" href="#列表渲染"><span>列表渲染</span></a></h2><p>可遍历：Array、Object、String、Number(指定次数)<br> 若遍历对象类型则遍历顺序由<code>Object.keys()</code>决定</p><p>v-for与v-if不推荐在同一层级使用，若放在同一层级，则v-if优先级较高, 因此v-if无法使用v-for中的变量</p><div class="language-vue line-numbers-mode" data-highlighter="prismjs" data-ext="vue" data-title="vue"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(item, index) in items<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>index<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>{{index + item.message}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(value, key, index) in customObject<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>{{index + value}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>列表渲染中推荐使用主键(每个item独一无二的值)绑定key，key辅助更新的原理：</p><div class="custom-container tip"><p class="custom-container-title">react、vue中的key的作用（key的内部原理）</p><ol><li>虚拟DOM中key的作用：<br> key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</li><li>对比规则：<br> (1). 旧虚拟DOM中找到了与新虚拟DOM相同的key：<br> ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！<br> ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。<br> (2). 旧虚拟DOM中未找到与新虚拟DOM相同的key<br> 创建新的真实DOM，随后渲染到到页面。 详细的对比规则参见<a class="route-link" href="/vue/vue2plus/#%E8%99%9A%E6%8B%9Fdom%E5%92%8Cdiff%E7%AE%97%E6%B3%95">虚拟dom和diff算法</a></li><li>用index作为key可能会引发的问题：<br> a. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:<br> 会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。<br> b. 如果结构中还包含输入类的DOM：<br> 会产生错误DOM更新 ==&gt; 界面有问题。</li><li>开发中如何选择key?:<br> a. 最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。<br> b. 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，<br> 使用index作为key是没有问题的。</li></ol></div><h2 id="表单" tabindex="-1"><a class="header-anchor" href="#表单"><span>表单</span></a></h2><p>使用v-model绑定收集表单数据，对于不同的输入元素将绑定不同的property和事件：</p><ul><li><code>&lt;input type=&quot;text&quot;/&gt;</code> 和 <code>&lt;textarea/&gt;</code> 元素使用 <code>value</code> property 和 <code>input</code> 事件；</li><li><code>&lt;input type=&quot;checkbox&quot;/&gt;</code> 和 <code>&lt;input type=&quot;radio&quot;/&gt;</code> 使用 <code>checked</code> property 和 <code>change</code> 事件；多个checkbox可绑定到同一数组上</li><li><code>&lt;select&gt;</code> 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li></ul><p>PS：v-model的三个修饰符：<br> lazy：失去焦点再收集数据, 即input事件后更新数据<br> number：输入字符串转为有效的数字<br> trim：输入首尾空格过滤<br> 关于v-model本质是语法糖，更多详细参见<a href="#%E6%8C%87%E4%BB%A4">指令</a>中v-model和v-bind.sync对比</p><h2 id="过滤器" tabindex="-1"><a class="header-anchor" href="#过滤器"><span>过滤器</span></a></h2><p>过滤器：(在vue3中被移除)<br> 定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。<br> 语法：<br> 1.注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}<br> 2.使用过滤器：0 或 v-bind:属性 = &quot;xxx | 过滤器名&quot;<br> 备注：<br> 1.过滤器也可以接收额外参数、多个过滤器也可以串联<br> 2.并没有改变原本的数据, 是产生新的对应的数据</p><h2 id="指令" tabindex="-1"><a class="header-anchor" href="#指令"><span>指令</span></a></h2><p>vue通过指令封装了有关DOM操作的逻辑模板中使用方法<code>&lt;div v-example:[arg].modifiers=&quot;value&quot;&gt;&lt;/div&gt;</code><br><code>v-example</code>为指令名称<br> arg是指令参数，可以<code>[arg]</code>的形式表示动态参数，动态参数字符串类型，不支持js表达式，<br> modifiers为指令修饰符<br> value是传给指令的值</p><ul><li>常用的内置指令：<br> v-bind : 单向绑定解析表达式, 可简写为 <code>:xxx</code><br> v-model : 双向数据绑定<br> v-for : 遍历数组/对象/字符串(<code>item in items</code>和<code>item of items</code>在Vue中没有区别)<br> v-on : 绑定事件监听, 可简写为@<br> v-if : 条件渲染（动态控制节点是否存存在）<br> v-else : 条件渲染（动态控制节点是否存存在）<br> v-show : 条件渲染 (动态控制节点是否展示)</li><li>v-text指令：<br> 1.作用：向其所在的节点中渲染文本内容。<br> 2.与插值语法的区别：v-text会替换掉节点中的内容，则不会。</li><li>v-html指令：<br> 1.作用：向指定节点中渲染包含html结构的内容。<br> 2.与插值语法的区别：<br> (1).v-html会替换掉节点中所有的内容，<code>{{xx}}</code>则不会。<br> (2).v-html可以识别html结构。<br> 3.严重注意：v-html有安全性问题！！！！<br> (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击(如：通过插入html向特定网站发送用户的cookie等数据)。<br> (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</li><li>v-cloak指令（没有值）：<br> 1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。<br> 2.使用css <code>diaplay:none</code>配合v-cloak可以解决网速慢时页面展示出模板<code>{{xxx}}</code>的问题。</li><li>v-once指令：<br> 1.v-once所在节点在初次动态渲染后，就视为静态内容了。<br> 2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</li><li>v-pre指令：<br> 1.跳过其所在节点的编译过程。<br> 2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</li><li>自定义指令总结： <ol><li><p>定义语法：<br> 1).局部指令：<br><code>new Vue({directive:{指令名:配置对象}})</code>或<br><code>new Vue({directive{指令名:回调函数}})</code> 简写模式回调函数默认是指bind和update<br> 2).全局指令：<br><code>Vue.directive(指令名,配置对象/回调函数)</code></p></li><li><p>配置对象中常用的回调：<br> 1)<code>bind(element, binding)</code>：指令与元素成功绑定时调用。<br> 2)<code>inserted(element, binding)</code>：指令所在元素被插入页面时调用。<br> 3)<code>update(element, binding)</code>：指令所在模板结构被重新解析时调用。<br> 4)<code>componentUpdated</code>指令所在组件的VNode及其子VNode全部更新后调用 5)<code>unbind</code>只调用一次，指令与元素解绑时调用</p></li><li><p>回调函数的参数：</p></li></ol></li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">element <span class="token comment">// 指令所绑定的元素，可直接操作DOM</span></span>
<span class="line"><span class="token literal-property property">binding</span><span class="token operator">:</span><span class="token punctuation">{</span></span>
<span class="line">  name <span class="token comment">// 指令名，不含v-前缀</span></span>
<span class="line">  value <span class="token comment">// 绑定的值</span></span>
<span class="line">  oldValue <span class="token comment">// 绑定的旧值</span></span>
<span class="line">  expression <span class="token comment">// 字符串形式的指令表达式</span></span>
<span class="line">  arg <span class="token comment">// 传给指令的参数, 如v-bind:arg=&quot;&quot;中的arg</span></span>
<span class="line">  modifiers <span class="token comment">// 修饰符对象, 如v-bind.sync =&gt; {sync:true}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line">vnode <span class="token comment">// 生成的虚拟节点</span></span>
<span class="line">oldVnode <span class="token comment">// 上一个虚拟节点</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>备注：<br> 1.指令定义时不加v-，但使用时要加v-；<br> 2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。<br> 3.指令绑定参数可以动态绑定</li></ol><div class="custom-container tip"><p class="custom-container-title">v-if指令应该注意的地方</p><p><code>v-if</code>指定修饰的节点在条件变为不满足时，将摧毁该节点及其子节点；当条件再变为满足时，新创建的节点及子节点与原有节点不同；<br> 这点在echarts这类需要持有DOM实例进行渲染的库中，由于持有的旧DOM实例与新节点的DOM实例不同，会出现不能渲染的情况，解决方案是在此类场景中使用<code>v-show</code>或重新获取新节点DOM并初始化echarts实例<br><code>v-if</code>与<code>v-else-if</code>等条件语句之间还存在着直接子节点复用的情况，添加key值可避免复用的情况发生<br> 总结下来高频切换用<code>v-show</code>，否则用<code>v-if</code><br> 另外<code>v-if</code>不推荐与<code>v-for</code>一起使用，当处于同一节点时<code>v-for</code>优先级更高，<code>v-if</code>会作用于循环中的每一个item</p></div><ul><li>v-model和v-bind.sync</li></ul><p>两个指令均可实现双向绑定，即子组件改变prop时变化能同步到父组件中<br> 其中<code>v-bind.sync</code> 通过自定义事件事件，在子组件中使用<code>this.$emit(&#39;update:prop名称&#39;, newVal)</code>的方式触发反向更新<br><code>v-bind.sync</code>不能与表达式一起使用，仅能提供property名<br> v-bind.sync本质是语法糖</p><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html" data-title="html"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>custom-component</span> <span class="token attr-name">:value.sync</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>custom-component</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">相当于</span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>custom-component</span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">@update:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value = $event<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>custom-component</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>v-model：v-model实际是v-bind.sync的语法糖，且每个组件仅能绑定一个v-model指令，对应text, textarea 的value属性反向更新绑定为input事件，而checkbox, select等为change事件,且仅能绑定到这些标签对应的固定值上<br> 在自定义组件中使用需要通过model选项定制其prop和event，否则默认事件为input，默认绑定prop为value</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token literal-property property">model</span><span class="token operator">:</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token literal-property property">prop</span><span class="token operator">:</span> <span class="token string">&#39;props name&#39;</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token literal-property property">event</span><span class="token operator">:</span> <span class="token string">&#39;change&#39;</span> <span class="token comment">// set default input event to change event</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token literal-property property">props</span><span class="token operator">:</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token string-property property">&#39;props name&#39;</span><span class="token operator">:</span> String</span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ps:在vue3中v-model的使用范围已和v-bind.sync相同，并且移除了v-bind的sync修饰符<br><a href="https://v3.cn.vuejs.org/guide/migration/v-model.html#%E6%A6%82%E8%A7%88" target="_blank" rel="noopener noreferrer">参考文档</a></p><h2 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期"><span>生命周期</span></a></h2><p><img src="/assets/lifecycle-BV7UNyk7.png" alt="lifecycle"></p><ul><li><p>常用的生命周期钩子：<br> 1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。<br> 2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</p></li><li><p>关于销毁Vue实例<br> 1.销毁后借助Vue开发者工具看不到任何信息。<br> 2.销毁后自定义事件会失效，但原生DOM事件依然有效。<br> 3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</p></li><li><p>父子组件生命周期执行顺序</p><ol><li>加载过程：父组件beforeCreate =&gt; 父组件created =&gt; 父组件beforeMount =&gt; 子组件beforeCreate =&gt; 子组件created =&gt; 子组件 beforeMount =&gt; 子组件mounted =&gt; 父组件mounted</li><li>更新过程：父组件beforeUpdate =&gt; 子组件beforeUpdate =&gt; 子组件updated =&gt; 父组件updated</li><li>销毁过程：父组件beforeDestroy =&gt; 子组件 beforeDestroy =&gt; 子组件 destroyed =&gt; 父组件 destroyed</li></ol></li></ul><h2 id="组件化编程" tabindex="-1"><a class="header-anchor" href="#组件化编程"><span>组件化编程</span></a></h2><p>Vue中使用组件的几大步骤：</p><ul><li>一、定义一个组件<br> 使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；<br> 1.编写组件时不挂载元素,因此不写el属性<br> 2.data必须写成函数形式,便于组件实例化时每次都生成新的数据对象<br> 3.在脚手架中推荐在options对象中使用name属性，其值命名多单词组成时可使用大驼峰(推荐方式,需在脚手架环境下)或<code>-</code>连字符的方式<br> 4.组件文件名命名推荐与name属性保持一致<br> 备注：使用template可以配置组件结构。<br> 全局定义组件时<code>const school = Vue.extend(options)</code>可简写为<code>const school = options</code></li></ul><p>或者通过编写<code>.vue</code>文件，再通过import的方式引入，也可定义一个组件</p><ul><li><p>二、注册组件<br> 1.局部注册：传入components选项</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">import</span> componentA <span class="token keyword">from</span> <span class="token string">&#39;./componentA&#39;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token literal-property property">components</span><span class="token operator">:</span><span class="token punctuation">{</span></span>
<span class="line">    componentA<span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.全局注册：<code>Vue.component(&#39;组件名&#39;,组件)</code></p></li><li><p>三、使用组件标签：<br> 闭合标签和自闭合标签(需脚手架环境webpack，vite等)均可,vue解析标签时实例化vue组件对象</p></li><li><p>四、组件与vm之间的关系<br> 内置关系：<code>VueComponent.prototype.__proto__ === Vue.prototype</code></p></li></ul><p>工程化项目中main.js文件中用于创建vm,唯一实例化的vue对象作为入口挂载组件,App.vue文件中定义根组件容器用于管理其它组件</p><p>ps：构造函数的prototype显式原型属性与其实例化后的实例的__proto__隐式原型属性指向同一个原型对象</p><h3 id="组件的函数式调用" tabindex="-1"><a class="header-anchor" href="#组件的函数式调用"><span>组件的函数式调用</span></a></h3><p>通过在父组件的生命周期中调用函数，从而使用子组件的方式。适合于简单组件如非模态的弹窗消息、loading遮罩等 定义方式示例：</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">import</span> MyMessage <span class="token keyword">from</span> <span class="token string">&#39;MyMessage.vue&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 以函数式调用的组件</span></span>
<span class="line"><span class="token keyword">const</span> MsgCreator <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span>MyMessage<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 生成MyMessage组件构造函数</span></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">createMessage</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> props<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> MsgVM <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MsgCreator</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 实例化组件此时可传入props数据,并使用$mount函数生成DOM</span></span>
<span class="line">  <span class="token comment">// 在此函数中还可通过事件监听、设置el等方式添加更多功能</span></span>
<span class="line">  el<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>MsgVM<span class="token punctuation">.</span>$el<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 操作DOM将组件追加到传入的el子元素末尾</span></span>
<span class="line">  <span class="token keyword">return</span> MsgVM <span class="token comment">// 返回MsgVM实例以便功能扩展</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">export</span> <span class="token punctuation">{</span>createMessage<span class="token punctuation">}</span>  <span class="token comment">// 暴露函数，调用方引入该函数并调用即可使用MyMessage组件</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="动态组件-component" tabindex="-1"><a class="header-anchor" href="#动态组件-component"><span>动态组件<code>&lt;component&gt;</code></span></a></h3><p>vue内置元素<code>&lt;component v-bind:is=&quot;switchComponentName&quot;&gt;</code><br> 通过<code>is</code>prop绑定已注册的组件名或组件的选项对象switchComponentName上，即可通过switchComponentName变量指定要使用的组件<br> 组件名也可用于普通的html标签，但普通标签的value等property需要使用<code>.prop</code>修饰器修饰，否则功能异常<br> 还可传入异步组件<code>defineAsyncComponent(()=&gt;import(&#39;component path&#39;))</code>实现按需加载<br><code>&lt;component&gt;</code>上绑定的属性将被透传到动态指定的组件上</p><h3 id="递归组件" tabindex="-1"><a class="header-anchor" href="#递归组件"><span>递归组件</span></a></h3><p>即组件在自己的模板中引用自身，此时要求组件有name选项或在全局注册<br> 编写递归组件时需要保证递归终止条件，否则会导致栈溢出max stack size exceeded错误</p><h3 id="组件间循环引用" tabindex="-1"><a class="header-anchor" href="#组件间循环引用"><span>组件间循环引用</span></a></h3><p>组件间的循环引用在打包时就会形成引用悖论，引发编译错误，解决此问题有如下方式：</p><ol><li>全都进行全局注册</li><li>在首先引用的那个组件A中通过beforeCreate生命周期钩子进行引入注册<code>beforeCreate(){ this.$options.components.yourComponent = require(&#39;url&#39;); }</code></li><li>注册组件时使用异步<code>() =&gt; import(&#39;url&#39;)</code>的方式注册</li></ol><h3 id="函数式组件-无状态无实例" tabindex="-1"><a class="header-anchor" href="#函数式组件-无状态无实例"><span>函数式组件(无状态无实例)</span></a></h3><p>组件内部没有管理任何状态，没有生命周期，也没有实例(没有this上下文), 仅接收一些props，类似于函数，因此可以设置functional属性<code>&lt;template functional&gt;</code>或<code>Vue.component(&#39;myComponent&#39;, {functional:true})</code>，将该组件变为一个函数式组件</p><p>函数式组件若是写成渲染函数的形式，则其render 函数接收第二个参数context作为上下文，context对象包含props, children, slots, scopedSlots, data(传递给组件的整个数据对象区别与普通组件的data选项，此处还包含data.on, data.attrs等), parent, listeners(data.on的别名), injections</p><p>前面有介绍组件的函数式调用，其本质仍然是普通组件，这是其与函数式组件最大的区别</p><p>函数式组件本质是一个函数，与之对应的是普通的类组件，其渲染开销低于类组件。通常用于包装子组件，在将children，props，data传递给子组件前操作这些属性</p><h2 id="组件间通信的方式" tabindex="-1"><a class="header-anchor" href="#组件间通信的方式"><span>组件间通信的方式</span></a></h2><ul><li>props &amp; emit</li></ul><p>props/emit仅适用于父子组件间通信，<a href="#%E7%BB%84%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%8F%8A%E9%85%8D%E7%BD%AE">props属性</a>只能从父组件单向流向子组件。<br> 要实现双向通信需配合自定义事件emit, 在父组件使用v-on绑定监听事件回调函数，在子组件中使用this.$emit触发对应事件，并回传相应参数即可实现子组件到父组件的数据流动。<br> 监听事件的回调函数上下文最终还是父组件。</p><div class="custom-container tip"><p class="custom-container-title">v-model和v-bind.sync</p><p>这两个指令基于props和emit实现的双向绑定也也可算作组件间通信的一种方式<br> 详见<a href="#%E6%8C%87%E4%BB%A4">指令</a>章节中的辨析</p></div><ul><li>EventBus 事件总线(发布订阅模式)</li></ul><p>基于自定义事件,普通自定义事件父组件通过v-on在子组件上订阅事件，并绑定回调函数，子组件中通过this.$emit触发对应事件并回传参数<br> 事件总线需要在全局注册发布者bus，一个组件中通过<code>bus.$emit(&#39;消息名&#39;, 传递参数)</code>发布消息，其他需要通信的组件通过<code>bus.$on(&#39;消息名&#39;, 回调函数(传递的参数))</code>订阅此消息。<br> 由于是全局对象，可以存在多个订阅者，组件间通信也不仅限于父子组件，任意组件间均可进行通信<br> 在组件销毁时需要通过<code>bus.$off(&#39;消息名&#39;, 回调函数)</code>的方式移除该事件的回调<br> 另外还有<code>$once</code>的方式监听事件对应回到函数仅执行一次</p><ul><li>provide &amp; inject</li></ul><p>provide/inject可以实现祖到孙组件间的通信,没有层级深度限制，且不会为数据增加额外的响应式(传入响应式数据则有响应式，没有则没有响应式)，<br> 祖组件中设置provide属性，提供可供注入的对象或返回对象的函数，子孙组件中使用inject属性(string[]/object)从提供的注入对象中选择要注入的属性。</p><div class="language-vue line-numbers-mode" data-highlighter="prismjs" data-ext="vue" data-title="vue"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"></span>
<span class="line"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span></span>
<span class="line">  provide：<span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token comment">// 为后代组件提供数据</span></span>
<span class="line">    <span class="token literal-property property">key</span><span class="token operator">:</span>value <span class="token punctuation">,</span> <span class="token comment">// key:string|symbol, value:any</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token literal-property property">inject</span><span class="token operator">:</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token comment">// key:string|symbol // 注入父级组件提供的数据</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>$parent</code> &amp; <code>$children</code>或ref</li></ul><p>利用<code>$parent</code>和<code>$children</code>属性获取父组件或子组件的实例，通过读取或操作对应的值即可实现父子组件间通信<br> 这种组件间通信方式仅应急状况下使用，不推荐大规模应用<br> PS: 与之相类似的还可通过<code>$root</code>访问到根实例</p><ul><li><code>$attrs</code> &amp; <code>$listeners</code></li></ul><p>该组合可进行祖孙组件间通信。<br><code>$attrs</code>当前组件包含了除props声明外的所有绑定属性(class、style除外)，可以类比为函数中的<code>...rest</code>参数<br> 当前组件可通过<code>v-bind=&quot;$attrs&quot;</code>将其接收的绑定属性传递到其子组件上，从而让孙组件可以访问到祖组件上传入的绑定属性<br><code>$listeners</code>与<code>$attrs</code>类似包含了v-on事件监听器(不含.native修饰的),同样使用<code>v-on=&quot;$listeners&quot;</code>可将接收的事件监听器传递到子组件中，让孙组件能够访问到事件，并通过<code>$emit</code>可触发该事件，并且当当前组件中额外绑定了同名事件时，孙组件会同时触发这两个事件，触发顺序类似于冒泡，因此尽量避免事件名重复</p><ul><li>全局状态管理</li></ul><p>vuex是一个全局状态管理库，详细特性及使用方法见<a class="route-link" href="/vue/vuex/">vuex</a><br><a class="route-link" href="/vue/Pinia.html">pinia</a>与vuex定位相同，但同时支持vue2和vue3</p><h2 id="组件属性及配置" tabindex="-1"><a class="header-anchor" href="#组件属性及配置"><span>组件属性及配置</span></a></h2><ul><li>ref属性</li></ul><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html" data-title="html"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>School</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&#39;</span>sch<span class="token punctuation">&#39;</span></span><span class="token punctuation">&gt;</span></span>  </span>
<span class="line">this.$refs.sch 可获取到真实的DOM元素或School组件实例对象  </span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>School</span><span class="token punctuation">&gt;</span></span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>props属性</li></ul><p>props类似于函数的参数，数据由父传子单向传递，若要进行子传父，需父组件先传递回调函数，子组件通过调用回调函数的方式向父组件传递数据，在子组件中不推荐直接修改父组件传过来的props数据<br> 若在子组件中尝试修改传入的props，vue会在控制台抛出错误，但由于js的对象或数组等传递方式是传引用，因此若props属性是一个对象或数组，直接修改其内部属性则可以修改成功并影响父组件<br> 常用写法如下:</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx" data-title="jsx"><pre><code><span class="line"><span class="token comment">// 在父组件中，使用v-bind传入name属性值data</span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child-component</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>data<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child-component</span> <span class="token attr-name">v-bind</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>data<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span> <span class="token comment">// 传入整个data对象，data对象的key-value将对应props中定义的属性名，类似于函数的参数解构</span></span>
<span class="line"><span class="token comment">// 子组件中</span></span>
<span class="line"><span class="token keyword">var</span> childComponent <span class="token operator">=</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">//简单声明接收  </span></span>
<span class="line">  <span class="token literal-property property">props</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">&#39;name&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;age&#39;</span><span class="token punctuation">,</span><span class="token string">&#39;sex&#39;</span><span class="token punctuation">]</span>  </span>
<span class="line">  <span class="token comment">// 类型限制  </span></span>
<span class="line">  <span class="token literal-property property">props</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token literal-property property">name</span><span class="token operator">:</span>String<span class="token punctuation">}</span>  </span>
<span class="line">  <span class="token comment">// 类型限制+默认值的指定+必要性的限制  </span></span>
<span class="line">  <span class="token literal-property property">props</span><span class="token operator">:</span><span class="token punctuation">{</span>  </span>
<span class="line">    <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token punctuation">{</span>  </span>
<span class="line">      <span class="token literal-property property">type</span><span class="token operator">:</span>String<span class="token punctuation">,</span>  </span>
<span class="line">      <span class="token literal-property property">required</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 与default属性二选一  </span></span>
<span class="line">      <span class="token comment">// default:&#39;张三&#39;  </span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关联话题<a href="#%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F">组件间通信</a></p><ul><li>mixin混入</li></ul><p>将vue配置项的一部分提取出去,给各组件复用的方式称为混入;<br> 局部混入:<code>import {mixinsObj, mixinObj2} from &#39;mixinsModules&#39;</code>,在配置项中使用<code>mixins:[mixinObj1,mixinObj2]</code><br> 全局混入:可以将mixinObj混入每一个vue实例中。导入后,通过<code>Vue.mixin(mixinObj1)</code>混入<br> 混入的配置项若有重复,不会覆盖组件中的原配置,<br> 混入的对象型选项会进行合并，若key值冲突，则组件的属性值将覆盖该选项，hook函数(生命周期函数等)则将合并调用，混入的hook优先被调用</p><p>Vue.extend()也采用了同样的策略进行合并</p><p>通过Vue.config.optionMergeStrategies.myOption可以自定义选项合并逻辑</p><ul><li>插件</li></ul><p>在实例化vm之前,调用<code>Vue.use(plugins,params)</code>的方式挂载插件<br> 传入plugins对象中必须包含install方法,install可以接收到Vue构造函数和params参数,在此阶段全局过滤器,全局混入,第三方库等功能挂载到原型对象上,增加vue的功能</p><p>TODO：<code>Vue.use</code>的调用为什么要在<code>new Vue</code>之前，若在之后会怎样 <a href="https://juejin.cn/post/6844903923321405453" target="_blank" rel="noopener noreferrer">vue.use</a></p><ul><li>scoped</li></ul><p>在vue文件中<code>&lt;style scoped&gt;&lt;/style&gt;</code>中使用该属性,标签中的样式将只在本组件中生效.<br> vue是通过将模板中的标签加入<code>data-随机数字</code>属性以及对css选择器添加<code>[data-随机数字]</code>来约束样式作用范围的</p><ul><li><code>$nextTick</code></li></ul><p><code>$nextTick</code>属性用于传入一个回调函数,该函数在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM.<br><code>$nextTick</code>也算是生命周期图之外的一个生命周期函数</p><ul><li>vue-resource</li></ul><p>vue-resource是vue1.×版本提供的ajax请求插件,vue2.0以后不再维护,推荐使用axios发起ajax请求</p><h2 id="插槽" tabindex="-1"><a class="header-anchor" href="#插槽"><span>插槽</span></a></h2><p>vue通过插槽向子组件中传递html结构<br> 由于结构是在父组件中定义的,所以结构的样式和数据也可引用父组件</p><ul><li>默认插槽</li></ul><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html" data-title="html"><pre><code><span class="line"><span class="token comment">&lt;!-- 父组件中 --&gt;</span>  </span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>子组件</span><span class="token punctuation">&gt;</span></span>要插入的html结构<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>子组件</span><span class="token punctuation">&gt;</span></span>  </span>
<span class="line"><span class="token comment">&lt;!-- 子组件中 --&gt;</span>  </span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">&gt;</span></span>默认值/结构<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span> <span class="token comment">&lt;!-- 要插入的html结构占位符 --&gt;</span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>具名插槽</li></ul><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html" data-title="html"><pre><code><span class="line"><span class="token comment">&lt;!-- 父组件中 --&gt;</span>  </span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>子组件</span><span class="token punctuation">&gt;</span></span>  </span>
<span class="line">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>占位1</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">    <span class="token comment">&lt;!-- 要插入占位1中的结构，v-slot指令仅可用于template标签上(被提供的内容仅有默认插槽时除外) --&gt;</span></span>
<span class="line">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>  </span>
<span class="line">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>占位2</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">    <span class="token comment">&lt;!-- 要插入占位2中的结构 --&gt;</span></span>
<span class="line">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>  </span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>子组件</span><span class="token punctuation">&gt;</span></span>  </span>
<span class="line"><span class="token comment">&lt;!-- 子组件中 --&gt;</span>  </span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&#39;</span>占位1<span class="token punctuation">&#39;</span></span><span class="token punctuation">&gt;</span></span>默认值/结构<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>  </span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&#39;</span>占位2<span class="token punctuation">&#39;</span></span><span class="token punctuation">&gt;</span></span>默认值/结构<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>作用域插槽</li></ul><p>父级模板中的所有内容都是在父级作用域中编译的；<br> 子组件的模板则是在子级作用域的中编译，因此要插入的html结构想要访问子组件中的变量，需要用到作用域插槽</p><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html" data-title="html"><pre><code><span class="line"><span class="token comment">&lt;!-- 父组件中 --&gt;</span>  </span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&#39;</span>childrenParams<span class="token punctuation">&#39;</span></span><span class="token punctuation">&gt;</span></span></span>
<span class="line">  <span class="token comment">&lt;!-- 将接收自子组件的变量重命名为了childrenParams --&gt;</span></span>
<span class="line">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html结构</span><span class="token punctuation">&gt;</span></span>{{childrenParams.params1}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html结构</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token comment">&lt;!-- 子组件中 --&gt;</span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">:params1</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>data1<span class="token punctuation">&quot;</span></span> <span class="token attr-name">params2</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&#39;</span>js表达式<span class="token punctuation">&#39;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token comment">&lt;!-- 可传递多个参数，将被包裹在一个对象中，name为保留key，不会作为参数传递 --&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外可以通过<code>&lt;template v-slot:[动态插槽名]&gt;&lt;/template&gt;</code>的方式定义动态的插槽名<br> 具名插槽中<code>v-slot:</code>在<code>:</code>后有参数时<code>v-slot:</code>部分可缩写为<code>#</code></p><h2 id="动态组件和异步组件" tabindex="-1"><a class="header-anchor" href="#动态组件和异步组件"><span>动态组件和异步组件</span></a></h2><p>动态切换的组件上，想要保持组件的状态可以使用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>包裹，能够避免创建组件，能够在频繁切换的场景下提升性能<br> 异步组件即以工厂函数的方式定义组件，工厂函数会异步的解析组件定义，vue仅在需要渲染时才会触发工厂函数，并且会缓存结果供未来重新渲染<br> 异步组件最常见的使用形式是与webpack的code split功能相结合，通过类似<code>() =&gt; import(&#39;./my-async-component&#39;)</code>的方式进行注册或导入，从而增强code split的效果，将应用切分成更小的代码块</p><h2 id="过渡" tabindex="-1"><a class="header-anchor" href="#过渡"><span>过渡</span></a></h2><p>vue在插入、更新、移除DOM或组件时提供不同的方式应用过渡效果，主要方式有：</p><ul><li>在 CSS 过渡和动画中自动应用 class，配合使用第三方 CSS 动画库，如 Animate.css</li><li>在过渡钩子函数中使用 JavaScript 直接操作 DOM，配合使用第三方 JavaScript 动画库，如 Velocity.js</li></ul><p>通过在<code>&lt;transition&gt;</code>上绑定hook可直接操作DOM自定义过渡效果，hook绑定支持8种:</p><div class="language-vue line-numbers-mode" data-highlighter="prismjs" data-ext="vue" data-title="vue"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition</span></span>
<span class="line">  <span class="token attr-name"><span class="token namespace">v-on:</span>before-enter</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(el) =&gt; {}<span class="token punctuation">&quot;</span></span></span>
<span class="line">  <span class="token attr-name"><span class="token namespace">v-on:</span>enter</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(el, done) =&gt; {done()}<span class="token punctuation">&quot;</span></span></span>
<span class="line">  <span class="token attr-name"><span class="token namespace">v-on:</span>after-enter</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(el) =&gt; {}<span class="token punctuation">&quot;</span></span></span>
<span class="line">  <span class="token attr-name"><span class="token namespace">v-on:</span>enter-cancelled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(el) =&gt; {}<span class="token punctuation">&quot;</span></span></span>
<span class="line"></span>
<span class="line">  <span class="token attr-name"><span class="token namespace">v-on:</span>before-leave</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(el) =&gt; {}<span class="token punctuation">&quot;</span></span></span>
<span class="line">  <span class="token attr-name"><span class="token namespace">v-on:</span>leave</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(el, done) =&gt; {done()}<span class="token punctuation">&quot;</span></span></span>
<span class="line">  <span class="token attr-name"><span class="token namespace">v-on:</span>after-leave</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(el) =&gt; {}<span class="token punctuation">&quot;</span></span></span>
<span class="line">  <span class="token attr-name"><span class="token namespace">v-on:</span>leave-cancelled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(el) =&gt; {}<span class="token punctuation">&quot;</span></span></span>
<span class="line"><span class="token punctuation">&gt;</span></span>实际使用过程中推荐使用function的形式绑定</span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>使用vue封装的<code>&lt;transition&gt;&lt;/transition&gt;</code>组件包裹需要动画的单标签或单根组件，这些标签或组件通常需要设置动态状态如:v-if、v-show、动态组件或组件根节点等</li></ul><p>当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理：</p><p>自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。<br> 主要包含6个类名: v-enter, v-enter-active, v-enter-to;v-leave, v-leave-active, v-leave-to; 各类名对应的状态及顺序详见<a href="https://v2.cn.vuejs.org/v2/guide/transitions.html#%E8%BF%87%E6%B8%A1%E7%9A%84%E7%B1%BB%E5%90%8D" target="_blank" rel="noopener noreferrer">官方文档</a><br> 若<code>&lt;transition&gt;</code>中设置了name属性，则类名前缀<code>v</code>会被替换为name属性值,设置<code>类名-class</code>的属性则可自定义过渡的类名，设置duration属性则可定制持续时间</p><p>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和 Vue 的 nextTick 概念不同)</p><ul><li>初始渲染的过渡</li></ul><p>通过appear属性设置节点在初始渲染的过渡，与默认的进入离开过渡一样也可以自定义类名与绑定hook</p><ul><li>多个元素过渡(元素切换)</li></ul><p>当元素切换时(通过v-if/v-else或<code>&lt;component&gt;</code>等方式)，一个离开过渡的时候另一个开始进入过渡，同时生效的过渡不能满足所有要求，vue的过渡模式提供了in-out属性：新元素先进行过渡，完成之后当前元素过渡离开;out-in：当前元素先进行过渡，完成之后新元素过渡进入;两种模式</p><ul><li>列表过渡</li></ul><p>列表过渡适用于使用了v-for指令的元素组，需要使用<code>&lt;transition-group&gt;</code>组件包裹，组件会转换为真实DOM，默认为<code>&lt;span&gt;</code>标签，且过渡模式不可用，内部元素需要指定唯一的key，css过渡的类会应用于内部元素中而不是组或元素本身<br> 列表过渡的类名在普通过渡的基础上增加了move用于改变定位时使用</p><p>PS：将<code>&lt;transition-group&gt;</code>或<code>&lt;transition&gt;</code>作为根组件进行封装能够对过渡效果进行复用，更推荐使用函数式组件的方式进行复用</p><ul><li>状态过渡</li></ul><p>组件中的状态，如节点位置，颜色显示，大小位置等其他属性发生变化可以利用响应式特性和组件结合一些css/js动效库，实现状态切换的过渡</p><p>详见<a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener noreferrer">官方文档</a></p><h2 id="渲染函数与jsx" tabindex="-1"><a class="header-anchor" href="#渲染函数与jsx"><span>渲染函数与jsx</span></a></h2><p><code>.vue</code>文件中的<code>&lt;template&gt;</code>经过模板编译阶段会生成render渲染函数，调用render会得到对应的虚拟DOM。<br> 通过编写render函数跳过模板编译阶段，从而获得更大的模板灵活性，但同时也要求对底层api较为熟悉<br> 在vue的options配置项中加入render选项:</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">&#39;myComponent&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">createElement</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token function">createElement</span><span class="token punctuation">(</span></span>
<span class="line">      <span class="token comment">// 添加render属性，使用createElement函数生成并返回虚拟DOM </span></span>
<span class="line">    <span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>createElement函数的入参</li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token literal-property property">tagName</span><span class="token operator">:</span> string<span class="token operator">|</span> object <span class="token operator">|</span> Function <span class="token comment">// 必填项，标签名或组件选项对象</span></span>
<span class="line"><span class="token literal-property property">attributeObject</span><span class="token operator">:</span><span class="token punctuation">{</span> <span class="token comment">// 可选，与模板中attribute对应的数据对象</span></span>
<span class="line">  <span class="token string-property property">&#39;class&#39;</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token literal-property property">foo</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token literal-property property">bar</span><span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 与v-bind:class api相同</span></span>
<span class="line">  <span class="token string-property property">&#39;style&#39;</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token literal-property property">color</span><span class="token operator">:</span><span class="token string">&#39;red&#39;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 与v-bind:style api相同</span></span>
<span class="line">  <span class="token literal-property property">attrs</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 普通attribute</span></span>
<span class="line">  <span class="token literal-property property">props</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 组件props属性</span></span>
<span class="line">  <span class="token literal-property property">domProps</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token literal-property property">innerHTML</span><span class="token operator">:</span><span class="token string">&#39;baz&#39;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// DOM properties</span></span>
<span class="line">  <span class="token literal-property property">on</span><span class="token operator">:</span><span class="token punctuation">{</span> <span class="token literal-property property">click</span><span class="token operator">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>clickHandler<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// v-on绑定的事件监听器</span></span>
<span class="line">  <span class="token literal-property property">nativeOn</span><span class="token operator">:</span><span class="token punctuation">{</span> <span class="token literal-property property">click</span><span class="token operator">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>nativeClickHandler<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 仅用于组件，监听原生事件</span></span>
<span class="line">  <span class="token literal-property property">directives</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 自定义的指令</span></span>
<span class="line">  <span class="token literal-property property">scopedSlots</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token function-variable function">default</span><span class="token operator">:</span><span class="token parameter">props</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 作用于插槽</span></span>
<span class="line">  <span class="token literal-property property">slot</span><span class="token operator">:</span> <span class="token string">&#39;name-of-slot&#39;</span><span class="token punctuation">,</span> <span class="token comment">// 作为子组件时，指定的插槽名称</span></span>
<span class="line">  <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token literal-property property">ref</span><span class="token operator">:</span> string<span class="token operator">|</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 若给多个元素都应用了相同的ref名，则会变成一个数组</span></span>
<span class="line">  <span class="token literal-property property">refInFot</span><span class="token operator">:</span> <span class="token boolean">true</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token literal-property property">childNode</span><span class="token operator">:</span> string <span class="token operator">|</span> Array <span class="token comment">// 文本节点或子级虚拟节点需要由createElement函数生成</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>PS:VNode必须唯一，因此多个相同的VNode需要用工厂函数实现<br> 渲染函数中v-if/v-for可以用条件判断或map等方式实现，而v-model语法糖则需要自行实现相关逻辑<br> 对于部分事件修饰符，提供了对应的修饰前缀，如<code>click.passive =&gt; &amp;click; click.capture =&gt; !click; click.once =&gt; ~click</code>,而其他修饰符基本可以从event参数中读取到并操作没有对应的修饰符<br> 通过this.$slots可以访问静态插槽的内容, 通过this.$scopedSlots访问作用域插槽</p><ul><li>jsx</li></ul><p>jsx风格的语法允许在js文件中直接书写xml风格的template语法，因此可以借助构建loader，用于代替上述createElement的函数式调用风格，如:</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx" data-title="jsx"><pre><code><span class="line"><span class="token punctuation">{</span> <span class="token comment">// 省略了其他配置项</span></span>
<span class="line">  <span class="token function-variable function">render</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token punctuation">(</span></span>
<span class="line">      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">AnchoredHeading</span></span> <span class="token attr-name">level</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text"></span>
<span class="line">        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Hello</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token plain-text"> world!</span>
<span class="line">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">AnchoredHeading</span></span><span class="token punctuation">&gt;</span></span></span>
<span class="line">    <span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="custom-container tip"><p class="custom-container-title">渲染函数在根实例上的体现</p><p>main.js文件中使用<code>render: h =&gt; h(App)</code>的原因是<br> 通过脚手架import的vue只包含核心功能没有模板解析器，因此不能使用template配置项，需要指定render选项<br> 函数接收到的createElement函数(简写为h)，调用h函数去解析App组件，并生成根实例的渲染函数</p></div><h2 id="cookbook" tabindex="-1"><a class="header-anchor" href="#cookbook"><span>Cookbook</span></a></h2><p>参考资料<a href="https://cn.vuejs.org/v2/cookbook/" target="_blank" rel="noopener noreferrer">Cookbook</a>中主要介绍了vue的编程技巧</p><h2 id="添加实例property" tabindex="-1"><a class="header-anchor" href="#添加实例property"><span>添加实例property</span></a></h2><p><code>vue.prototype.$appName = &#39;My App&#39;</code>其中<code>$</code>符号是为了避免命名冲突而约定的符号。 当在原型时绑定自定义函数时，该函数通过this，能够访问到实例的作用域。</p><h2 id="表单校验" tabindex="-1"><a class="header-anchor" href="#表单校验"><span>表单校验</span></a></h2><h2 id="vue-cli" tabindex="-1"><a class="header-anchor" href="#vue-cli"><span>vue-cli</span></a></h2><p>vue-cli是基于webpack等打包工具的</p><h3 id="vue-lib模式打包生成umd文件笔记" tabindex="-1"><a class="header-anchor" href="#vue-lib模式打包生成umd文件笔记"><span>vue lib模式打包生成umd文件笔记</span></a></h3><p>通过使用vue<a href="https://cli.vuejs.org/zh/guide/build-targets.html#%E5%BA%93" target="_blank" rel="noopener noreferrer">打包命令</a>中的target参数 指定构建模式为lib，可打包生产umd文件。<br> lib模式下默认不会打包vue，若要打包vue可使用命令<code>vue-cli-service build --target lib --inline-vue</code> 打包完成后可生成文件<br> ×××.common.js: 一个给打包器用的 CommonJS 包 (webpack 目前还并没有支持 ES modules 输出格式的包)<br> ×××.umd.js: 一个直接给浏览器或 AMD loader 使用的 UMD 包<br> ×××.umd.min.js: 压缩后的 UMD 构建版本<br> ×××.css: 提取出来的 CSS 文件 (可以通过在 vue.config.js 中设置css: { extract: false } 强制内联)</p><h2 id="关联问题js模块化历史" tabindex="-1"><a class="header-anchor" href="#关联问题js模块化历史"><span>关联问题js模块化历史</span></a></h2><ol><li>立即执行函数<br> 通过立即执行函数封装一个局部作用域</li><li>CommonJS标准<br> nodejs出现后为了解决打包文件相互依赖问题，出现了commonjs语法 引入使用var fs = require(&#39;fs&#39;), 导出使用module.export a = 1;</li><li>AMD(异步模块定义)<br> Commonjs是同步执行，但浏览器经常需要异步加载资源，于是有了AMD的语法，通过回调方式拿到异步变量 require(&#39;vue&#39;, (Vue) =&gt; {new Vue();})</li><li>import/export<br> 为了统一2、3两种方式js委员会发布了标准的import/export语法，通过import导入模块，export导出模块。同时，这种打包方式能够更好的在编译时进行静态优化 这种标准随之es6标准一起出现，因此也称这种模块为es6模块</li></ol><p>UMD(统一模块定义):这种模块语法会自动监测开发人员使用的是 Common.js/AMD/import/export 种的哪种方式，然后再针对各自的语法进行导出，这种方式可以兼容所有其他的模块定义方法。</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: vitotu@qq.com">vito</span><!----><!--]--><!--]--></span></div></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-CeNZkc-K.js" defer></script>
  </body>
</html>
