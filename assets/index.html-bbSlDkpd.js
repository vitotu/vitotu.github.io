import{_ as e,c as a,o as r,d as s}from"./app-DNIMQP_y.js";const n={},i=s('<h1 id="javascript异步编程读书笔记" tabindex="-1"><a class="header-anchor" href="#javascript异步编程读书笔记"><span>JavaScript异步编程读书笔记</span></a></h1><h2 id="序" tabindex="-1"><a class="header-anchor" href="#序"><span>序</span></a></h2><p>本书写的较早,很多案例和讲解的api都以jQuery或一些较老的库为样例,但其中的思想值得借鉴,实际应用中以新的api为准</p><h2 id="深入理解javascript事件" tabindex="-1"><a class="header-anchor" href="#深入理解javascript事件"><span>深入理解JavaScript事件</span></a></h2><p>setTimeout,setInterval计时函数并不是准确的延时后运行的，而是准确的延时后加入任务队列,等待，上一段代码执行完成后再执行；</p><p>一个函数在将来会导致另一个函数的运行，这个函数被称为异步的，被运行的函数称为回调函数。<br> 间或异步函数：只在某些时刻是异步的；缓存型异步函数，可缓存结果的异步请求类函数</p><p>通过延时而重复相同的函数调用(异步递归),异步递归次数不受限制，容易造成程序崩溃，谨慎使用。仅当没有回调机制时使用</p><p>异步函数中抛出的错误只能通过回调捕获，未捕获的异常可能会由运行环境捕获，提倡将throw用作断言结构</p><h2 id="分布式事件" tabindex="-1"><a class="header-anchor" href="#分布式事件"><span>分布式事件</span></a></h2><h3 id="pubsub模式" tabindex="-1"><a class="header-anchor" href="#pubsub模式"><span>PubSub模式</span></a></h3><p>如果想向一个元素的事件绑定多个响应函数(回调函数)，需要使用addEventListener方法，一旦发生该事件，则会触发多个回调函数。这种模式称为发布订阅模式(PubSub)。nodejs中则是通过EventEmitter对象实现</p><h3 id="事件化模型" tabindex="-1"><a class="header-anchor" href="#事件化模型"><span>事件化模型</span></a></h3><p>只要对象有PubSub接口，就能称为事件化对象.模型改变(数据改变),触发事件进而导致DOM更新的机制称为事件化模型.</p><p>对象a的一个事件x触发了对象b的事件y,而y又触发了x,这种相互触发的情况导致了事件循环,但实际双向绑定又必须利用事件循环,因此通常的解决措施是防止在短时间内重复触发.</p><h2 id="promise对象和deferred对象" tabindex="-1"><a class="header-anchor" href="#promise对象和deferred对象"><span>Promise对象和Deferred对象</span></a></h2><p>在一般性用法中,Promise、Deferred和Future这三个词大体可算作同义词,Deferred算是Promise的超集,Deferred实例可以直接触发</p><p>本章中大部分内容在讨论jQuery的Promise语法,其中使用到的思想,Promise对象、管道、Promise对象的合并处理等功能均已在es6中实现，至于进度通知还有待进一步学习</p><h2 id="async的工作流控制" tabindex="-1"><a class="header-anchor" href="#async的工作流控制"><span>Async的工作流控制</span></a></h2><p>Async.js的async.filter、async.forEach、async.filterSeries、async.forEachSeries用于将异步操作序列化，按照顺序执行。类似于es6中的async函数</p><p>async.series和async.waterfall也能实现顺序操作接受一个函数集而不是数据集，async.parallel则支持并行运行类似es6中的Promise.all系列方法</p><p>async.queue队列则在并行的基础上可以控制并发度(防止高并发导致系统崩溃),其返回值为一个队列可以向队列中push任务</p><h2 id="worker对象的多线程技术" tabindex="-1"><a class="header-anchor" href="#worker对象的多线程技术"><span>worker对象的多线程技术</span></a></h2><p>web版的worker对象的使用与事件化模型类似，主要用于解码视频，解析网页式编辑器中的文本。<br> worker对象看不到window对象、主线程及其他线程中的对象postMessage发送的消息会被序列化，类似JSON，importScripts同步加载脚本函数可用于子线程中</p><p>node版使用cluster(集群)对象来实现多线程，但cluster不是用过指定脚本而是把运行自己的同一个脚本再次加载，其消息通信方法和web版相似</p><h2 id="异步的脚本加载" tabindex="-1"><a class="header-anchor" href="#异步的脚本加载"><span>异步的脚本加载</span></a></h2><p>作者使用了较老的加载方式，需要通过第三方库实现异步加载。es6中提供了import()函数可实现异步加载</p>',26),t=[i];function l(p,c){return r(),a("div",null,t)}const h=e(n,[["render",l],["__file","index.html.vue"]]),o=JSON.parse('{"path":"/js/jsAsync/","title":"JavaScript异步编程读书笔记","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"序","slug":"序","link":"#序","children":[]},{"level":2,"title":"深入理解JavaScript事件","slug":"深入理解javascript事件","link":"#深入理解javascript事件","children":[]},{"level":2,"title":"分布式事件","slug":"分布式事件","link":"#分布式事件","children":[{"level":3,"title":"PubSub模式","slug":"pubsub模式","link":"#pubsub模式","children":[]},{"level":3,"title":"事件化模型","slug":"事件化模型","link":"#事件化模型","children":[]}]},{"level":2,"title":"Promise对象和Deferred对象","slug":"promise对象和deferred对象","link":"#promise对象和deferred对象","children":[]},{"level":2,"title":"Async的工作流控制","slug":"async的工作流控制","link":"#async的工作流控制","children":[]},{"level":2,"title":"worker对象的多线程技术","slug":"worker对象的多线程技术","link":"#worker对象的多线程技术","children":[]},{"level":2,"title":"异步的脚本加载","slug":"异步的脚本加载","link":"#异步的脚本加载","children":[]}],"git":{"updatedTime":1651996667000,"contributors":[{"name":"vito","email":"vitotu@qq.com","commits":1}]},"filePathRelative":"js/jsAsync/README.md"}');export{h as comp,o as data};
