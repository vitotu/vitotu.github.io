(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{488:function(r,a,e){"use strict";e.r(a);var s=e(62),t=Object(s.a)({},(function(){var r=this,a=r.$createElement,e=r._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h1",{attrs:{id:"javascript异步编程读书笔记"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript异步编程读书笔记"}},[r._v("#")]),r._v(" JavaScript异步编程读书笔记")]),r._v(" "),e("h2",{attrs:{id:"序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#序"}},[r._v("#")]),r._v(" 序")]),r._v(" "),e("p",[r._v("本书写的较早,很多案例和讲解的api都以jQuery或一些较老的库为样例,但其中的思想值得借鉴,实际应用中以新的api为准")]),r._v(" "),e("h2",{attrs:{id:"深入理解javascript事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#深入理解javascript事件"}},[r._v("#")]),r._v(" 深入理解JavaScript事件")]),r._v(" "),e("p",[r._v("setTimeout,setInterval计时函数并不是准确的延时后运行的，而是准确的延时后加入任务队列,等待，上一段代码执行完成后再执行；")]),r._v(" "),e("p",[r._v("一个函数在将来会导致另一个函数的运行，这个函数被称为异步的，被运行的函数称为回调函数。"),e("br"),r._v("\n间或异步函数：只在某些时刻是异步的；缓存型异步函数，可缓存结果的异步请求类函数")]),r._v(" "),e("p",[r._v("通过延时而重复相同的函数调用(异步递归),异步递归次数不受限制，容易造成程序崩溃，谨慎使用。仅当没有回调机制时使用")]),r._v(" "),e("p",[r._v("异步函数中抛出的错误只能通过回调捕获，未捕获的异常可能会由运行环境捕获，提倡将throw用作断言结构")]),r._v(" "),e("h2",{attrs:{id:"分布式事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式事件"}},[r._v("#")]),r._v(" 分布式事件")]),r._v(" "),e("h3",{attrs:{id:"pubsub模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pubsub模式"}},[r._v("#")]),r._v(" PubSub模式")]),r._v(" "),e("p",[r._v("如果想向一个元素的事件绑定多个响应函数(回调函数)，需要使用addEventListener方法，一旦发生该事件，则会触发多个回调函数。这种模式称为发布订阅模式(PubSub)。nodejs中则是通过EventEmitter对象实现")]),r._v(" "),e("h3",{attrs:{id:"事件化模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件化模型"}},[r._v("#")]),r._v(" 事件化模型")]),r._v(" "),e("p",[r._v("只要对象有PubSub接口，就能称为事件化对象.模型改变(数据改变),触发事件进而导致DOM更新的机制称为事件化模型.")]),r._v(" "),e("p",[r._v("对象a的一个事件x触发了对象b的事件y,而y又触发了x,这种相互触发的情况导致了事件循环,但实际双向绑定又必须利用事件循环,因此通常的解决措施是防止在短时间内重复触发.")]),r._v(" "),e("h2",{attrs:{id:"promise对象和deferred对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise对象和deferred对象"}},[r._v("#")]),r._v(" Promise对象和Deferred对象")]),r._v(" "),e("p",[r._v("在一般性用法中,Promise、Deferred和Future这三个词大体可算作同义词,Deferred算是Promise的超集,Deferred实例可以直接触发")]),r._v(" "),e("p",[r._v("本章中大部分内容在讨论jQuery的Promise语法,其中使用到的思想,Promise对象、管道、Promise对象的合并处理等功能均已在es6中实现，至于进度通知还有待进一步学习")]),r._v(" "),e("h2",{attrs:{id:"async的工作流控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#async的工作流控制"}},[r._v("#")]),r._v(" Async的工作流控制")]),r._v(" "),e("p",[r._v("Async.js的async.filter、async.forEach、async.filterSeries、async.forEachSeries用于将异步操作序列化，按照顺序执行。类似于es6中的async函数")]),r._v(" "),e("p",[r._v("async.series和async.waterfall也能实现顺序操作接受一个函数集而不是数据集，async.parallel则支持并行运行类似es6中的Promise.all系列方法")]),r._v(" "),e("p",[r._v("async.queue队列则在并行的基础上可以控制并发度(防止高并发导致系统崩溃),其返回值为一个队列可以向队列中push任务")]),r._v(" "),e("h2",{attrs:{id:"worker对象的多线程技术"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#worker对象的多线程技术"}},[r._v("#")]),r._v(" worker对象的多线程技术")]),r._v(" "),e("p",[r._v("web版的worker对象的使用与事件化模型类似，主要用于解码视频，解析网页式编辑器中的文本。"),e("br"),r._v("\nworker对象看不到window对象、主线程及其他线程中的对象postMessage发送的消息会被序列化，类似JSON，importScripts同步加载脚本函数可用于子线程中")]),r._v(" "),e("p",[r._v("node版使用cluster(集群)对象来实现多线程，但cluster不是用过指定脚本而是把运行自己的同一个脚本再次加载，其消息通信方法和web版相似")]),r._v(" "),e("h2",{attrs:{id:"异步的脚本加载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异步的脚本加载"}},[r._v("#")]),r._v(" 异步的脚本加载")]),r._v(" "),e("p",[r._v("作者使用了较老的加载方式，需要通过第三方库实现异步加载。es6中提供了import()函数可实现异步加载")])])}),[],!1,null,null,null);a.default=t.exports}}]);